Below is a **comprehensive Q&A guide (205 questions & answers)** that targets every skill listed in the job description.  
Use it to revise concepts, practice answering out‑loud, and identify any gaps you need to fill before the interview.

---

## 1️⃣ Go Language – Core & Advanced (20)

| # | Question | Answer |
|---|----------|--------|
|1|What are the main differences between **`var`**, **`:=`**, and **`new`** in Go?|`var` declares a variable with an explicit type (or inferred) and zero‑value initialization. `:=` is short‑hand declaration inside a function, infers the type and also zero‑values. `new(T)` allocates zeroed storage for type `T` and returns a pointer `*T`; it does **not** call any constructor.|
|2|Explain Go’s **type inference** rules for a variable declared with `:=`.|The compiler infers the type from the right‑hand side expression. The inferred type must be a single, non‑blank identifier; you cannot infer a type from a multi‑value return (except by using a tuple).|
|3|What is the **zero value** for each of the following Go types: `int`, `string`, `bool`, `slice`, `map`, `pointer`, `interface`? |`int` → 0, `string` → `""`, `bool` → `false`, `slice` → `nil`, `map` → `nil`, `pointer` → `nil`, `interface` → `nil`.|
|4|How does **method set** differ for a value receiver vs a pointer receiver?|A type `T`’s method set includes all methods with a **value receiver**. A pointer type `*T` includes both pointer‑receiver and value‑receiver methods. Hence, an interface requiring a pointer‑receiver method can only be satisfied by `*T`.|
|5|What is **interface satisfaction** in Go and how is it checked?|Satisfaction is implicit: a type implements an interface if it defines all the interface’s methods with matching signatures. The compiler checks this at assignment/usage time, not at declaration.|
|6|Why does Go have **no inheritance**? What alternatives does it provide?|Go favors composition over inheritance to avoid the fragility of deep hierarchies. Alternatives: embedding, interfaces, and delegation allow code reuse and polymorphism while keeping the type system simple.|
|7|Explain the purpose of the **`context`** package. How would you use it in a high‑concurrency service?|`context.Context` carries deadlines, cancellation signals, and request‑scoped values across API boundaries. In a service: create a root context per request, pass it downstream, check `ctx.Err()` in long‑running goroutines, and propagate cancellation to free resources.|
|8|What is the **`init`** function and when is it executed?|`init` runs automatically after all package‑level variable initialization, before `main`. Each file may have its own `init`; multiple `init`s in a package execute in lexical file order.|
|9|How does **garbage collection** work in Go (generational, mark‑and‑sweep, etc.)?|Go’s GC is a concurrent, non‑generational, tri‑color mark‑and‑sweep collector with a **background** marking phase, incremental sweeping, and a **finalizer** phase. It uses a **write barrier** and runs in parallel with the mutator to keep pause times low.|
|10|What are **escape analysis** and its impact on performance?|During compilation, the compiler decides whether a variable can be allocated on the stack or must “escape” to the heap (e.g., referenced by a goroutine). Escaping variables incur heap allocation & GC overhead; avoiding escapes improves latency.|
|11|Explain the difference between **buffered** and **unbuffered** channels. When would you prefer each?|Unbuffered channels block the sender until a receiver is ready (synchronization). Buffered channels have a capacity; senders block only when the buffer is full. Use unbuffered for strict hand‑off, buffered for pipeline stages where you want limited decoupling.|
|12|What is a **select** statement used for? Give a sample pattern.|`select` waits on multiple channel operations, proceeding with whichever is ready first. Common pattern: “fan‑in” from multiple workers, or implementing a timeout `<-time.After(d)`.|
|13|Describe **deadlock** detection in Go. How can you intentionally avoid it?|The runtime panics when all goroutines are blocked and no runnable goroutine exists (deadlock). Avoid by ensuring every send has a corresponding receive, using buffered channels, or designing non‑blocking algorithms (e.g., using `select` with default).|
|14|What is the **`sync/atomic`** package? When should you use it instead of mutexes?|Provides low‑level atomic memory primitives (Load, Store, Add, CompareAndSwap). Use it for lock‑free counters, flags, or when contention on a mutex would be a bottleneck, and when operations are simple single‑word manipulations.|
|15|Explain **`sync.WaitGroup`** and its typical usage pattern.|`WaitGroup` tracks a set of goroutines. Call `Add(n)` before launching, each goroutine calls `Done()` when finished, and the parent calls `Wait()` to block until the counter reaches zero.|
|16|What’s the difference between **`sync.Mutex`** and **`sync.RWMutex`**?|`Mutex` provides exclusive lock. `RWMutex` distinguishes read vs write: multiple readers can hold the lock simultaneously, but writers obtain exclusive access. Use `RWMutex` when reads heavily outweigh writes.|
|17|How would you implement a **thread‑safe LRU cache** in Go?|Combine a `map[key] *list.Element` for O(1) look‑up with a doubly‑linked `container/list` to track recency, guarding both structures with a `sync.Mutex`. Provide `Get`, `Put`, and `Remove` methods that update the list order under lock.|
|18|What does **`go vet`** check for? Give examples of common warnings it emits.|Static analysis tool detecting suspicious constructs: mismatched `Printf` arguments, unreachable code, `struct` tags errors, unsynchronized access to `sync.WaitGroup` counters, and misuse of `context`.|
|19|Explain **build tags** and how they are used in multi‑platform Go projects.|Build tags (`// +build linux,amd64`) are comments that control file inclusion based on OS, architecture, or custom tags. They allow you to compile platform‑specific implementations (e.g., using syscalls).|
|20|How would you debug a **goroutine leak** in production?|1. Capture a goroutine dump (`runtime.Stack` or `pprof`). 2. Look for many goroutines stuck in a blocked state (e.g., waiting on channel). 3. Correlate with recent code changes. 4. Add timeouts/cancellation (contexts) and instrumentation (metrics for goroutine count).|

---

## 2️⃣ Go Concurrency Patterns (30)

| # | Question | Answer |
|---|----------|--------|
|21|What is the **worker‑pool pattern** and how would you implement it in Go?|Create a fixed number of worker goroutines that read tasks from a shared job channel. The main goroutine pushes jobs into the channel and closes it when done. Workers range over the channel, process tasks, and signal completion via a `WaitGroup`.|
|22|Explain the **pipeline pattern** and when it is advantageous.|Chain multiple stages where each stage runs in its own goroutine, reads from an input channel, processes data, and writes to an output channel. Useful for streaming large data sets, decoupling work, and exploiting parallelism while bounding memory usage.|
|23|How do you implement **fan‑out/fan‑in** using channels?|Fan‑out: start N goroutines each reading from the same source channel. Fan‑in: merge their result channels into a single channel via a `select` loop or a dedicated `merge` function that forwards each value until all sources close.|
|24|When would you use a **sync.Cond**? Provide a simple example.|When you need to block goroutines until a particular condition becomes true, and you want to broadcast/wake a subset. Example: a bounded buffer where producers wait when full and consumers signal when they consume.|
|25|What are **idiomatic ways** to impose **timeouts** on channel operations?|Use `select` with a `time.After(d)` case: `select { case val := <-ch: // success case case <-time.After(d): // timeout }`.|
|26|Describe **back‑pressure** in a Go pipeline. How can you control it?|Back‑pressure occurs when downstream stages cannot keep up, causing upstream to block. Control it by adding bounded buffers (channel capacity) or “rate limiter” (`golang.org/x/time/rate`) to throttle input.|
|27|What is a **context‑aware** function and why is it important in distributed services?|A function that accepts a `context.Context` as its first argument and respects cancellation, deadlines, and request‑scoped values. It prevents resource leaks and propagates timeouts across service boundaries.|
|28|Explain **atomic compare‑and‑swap (CAS)** and give a use‑case.|CAS atomically checks if a memory location equals an expected value; if so, swaps it for a new value. Use‑case: lock‑free map entry insertion, or implementing a spin lock / simple state machine without a mutex.|
|29|How does the **`runtime.GOMAXPROCS`** setting affect concurrency?|It controls the maximum number of OS threads that can execute Go code simultaneously. By default, it equals the number of logical CPUs. Adjusting it can limit parallelism or allow more goroutines to run on constrained hardware.|
|30|What is a **goroutine leak** and how can you detect it during testing?|A goroutine that never exits (blocked or looping) after the test ends, consuming resources. Detect with `runtime.NumGoroutine()` before/after test, `pprof` heap profiles, or a test harness that fails if goroutine count grows beyond a threshold.|
|31|Explain the **“worker‑first”** vs **“task‑first”** approach in a pool.|Worker‑first: create a fixed set of workers that pull tasks from a shared queue (common). Task‑first: spawn a new goroutine for every incoming request (easier but can lead to unbounded concurrency).|
|32|How would you implement a **rate limiter** using Go’s standard library?|Use `time.Tick` or `time.NewTicker` to generate tokens at a fixed interval, combined with a buffered channel representing the token bucket. Each request attempts to receive a token; if none, it blocks or is rejected.|
|33|What is **`sync.Once`** and when should you use it?|Provides a thread‑safe way to ensure a piece of code runs exactly once, even across multiple goroutines. Typical for lazy initialization of singletons, opening DB connections, or registering metrics.|
|34|Explain the **“lazy initialization”** pattern with `sync.Once`.|Define a variable (e.g., `var db *sql.DB`) and a `sync.Once` instance. In a getter function, call `once.Do(func(){ db = initDB() })`. The DB connection is created the first time the getter runs, safely across goroutines.|
|35|What’s the difference between **`defer`** execution timing and **`recover`**?|`defer` statements run after the surrounding function returns, in LIFO order. `recover` can be called inside a deferred function to catch a panic, preventing the program from crashing and allowing graceful cleanup.|
|36|How would you **circuit‑break** a flaky external service using Go?|Wrap calls with a circuit‑breaker implementation (e.g., `github.com/sony/gobreaker`). Track successive failures; when a threshold is reached, open the circuit and return an error immediately. After a cooldown, allow a trial request (half‑open) to see if the service recovered.|
|37|What are **memory fences** and does Go expose them?|Memory fences ensure ordering of reads/writes across CPUs. Go exposes them indirectly via the `sync/atomic` package (e.g., `Load`, `Store`, `CompareAndSwap` have full memory barriers).|
|38|Explain **channel directionality** (`chan<-` / `<-chan`). Why is it useful?|A `chan<- T` can only be sent to; `<-chan T` can only be received from. This enforces compile‑time API contracts, preventing misuse (e.g., exposing a send‑only channel to a consumer).|
|39|When would you prefer a **`sync.Map`** over a plain `map` with a mutex?|High read‑mostly workloads with many goroutines, or when the map size grows dynamically and you want lock‑free reads. `sync.Map` uses segment locking and specialized algorithms for better scalability.|
|40|Describe **bounded vs unbounded** channel implementations. How can you build an unbounded channel?|Bounded channels have a fixed capacity; senders block when full. An unbounded channel can be built by chaining a buffered channel with a goroutine that continuously reads from an internal slice and forwards to the output channel, effectively decoupling producers from consumers without blocking.|
|41|How can you **profile** CPU and contention in a concurrent Go program?|Use `go test -bench=. -benchmem -run=^$ -cpuprofile=cpu.out` and `go tool pprof`. For contention, enable the race detector (`-race`) or use `runtime/pprof` with `trace` (`go test -trace=trace.out`). The trace shows goroutine scheduling and blocking events.|
|42|What is the **“select‑default”** pattern for non‑blocking channel ops?|`select { case v := <-ch: // got value case <-time.After(d): // timeout default: // would block }`. The `default` case executes immediately if no other case can proceed, making the operation non‑blocking.|
|43|Explain **goroutine scheduling** in Go runtime (M, P, G).|`M` = OS thread, `P` = processor context (holds runnable goroutine queue), `G` = goroutine. Scheduler maps many `G`s onto a limited set of `P`s (usually `runtime.GOMAXPROCS`). `M`s acquire a `P` to execute `G`s, then release.|
|44|What is a **“spurious wakeup”** and does Go’s `sync.Cond` guard against it?|A spurious wakeup occurs when a waiting goroutine is unblocked without the condition being true. Go’s `sync.Cond` does **not** protect against this; you must always re‑check the predicate in a loop (`for !cond { c.Wait() }`).|
|45|How would you design a **graceful shutdown** for a server handling many goroutines?|1. Capture OS signal (`os/signal`). 2. Cancel a top‑level context. 3. All request‑handling goroutines listen to the context and stop accepting new work. 4. Use a `WaitGroup` to wait for in‑flight goroutines. 5. Close listeners, DB connections, etc.|
|46|Give an example of **double‑checked locking** in Go. Is it safe?|```go
var cfg *Config
var once sync.Once

func GetConfig() *Config {
    once.Do(func(){ cfg = load() })
    return cfg
}
```  
Yes, `sync.Once` guarantees safe initialization; classic double‑checked locking using plain mutexes is error‑prone in Go due to reordering.|
|47|What is **`runtime.Gosched()`** and when might you use it?|Yields the processor, allowing other goroutines to run. Useful in tight loops where you want to avoid starving other goroutines, but generally not needed because the scheduler pre‑emptively yields.|
|48|Explain **lock ordering** and how it prevents deadlocks.|Define a global order for acquiring multiple locks (e.g., always lock `A` before `B`). All code follows this order, eliminating circular wait conditions, thus preventing deadlocks.|
|49|How does **`sync.Pool`** work and what are its typical use‑cases?|A pool of temporary objects that may be reused, reducing GC pressure. When `Get` is called, it tries to pull an object from the pool; `Put` returns it. Objects may be dropped at any time (GC). Use‑cases: per‑request buffers, temporary structs, database connections (rare).|
|50|What are **goroutine “leak detectors”** you can use in CI?|`go vet -run=atomic` can spot some, but dedicated tools: `golang.org/x/tools/go/analysis/passes/atomic` or third‑party `github.com/nytimes/golang-leak` and `uber-go/automaxprocs` for resource caps. Also use custom test helpers that compare `runtime.NumGoroutine()` before/after.|
|51|Explain the **“producer‑consumer”** problem and a Go solution.|Multiple producers generate data; multiple consumers process it. Solution: a buffered channel acts as the shared queue. Producers `ch <- item`; consumers `item := <-ch`. Use `sync.WaitGroup` to signal completion.|
|52|What is the difference between **`time.Sleep`** and **`time.After`** in concurrency?|`Sleep` blocks the current goroutine for a fixed duration. `After` returns a channel that delivers the current time after the duration; it can be used in a `select` to wait alongside other events without blocking the goroutine entirely.|
|53|How would you **limit the number of concurrent database connections** using channels?|Create a semaphore channel with capacity equal to the max connections: `sema := make(chan struct{}, max)`. Before a DB operation: `sema <- struct{}{}`; after the operation: `<-sema`. This blocks when the limit is reached.|
|54|What is **“back‑off retry”** and how can you implement exponential back‑off in Go?|Retry with increasing delays to reduce load on a failing service. Implementation: `for i:=0; i<max; i++ { if err:=fn(); err==nil {return} ; time.Sleep(time.Duration(math.Pow(2,float64(i))) * base) }`. Use jitter (`rand.Int63n`) to avoid thundering herd.|
|55|Explain **`runtime.GC()`** – when would you call it manually?|Forces a garbage collection cycle. Normally you let the runtime decide, but you might call it after a large amount of temporary memory is released (e.g., after processing a huge batch) to reclaim memory promptly. Overuse harms latency.|
|56|What are **`sync/Once`** vs **`init()`** for initialization?|`init()` runs automatically at package load, regardless of whether the code is used. `sync.Once` runs lazily and only when needed, safe across concurrency, and can be called multiple times without re‑initializing.|
|57|How would you **measure latency** of a critical operation in production code without affecting performance?|Instrument with OpenTelemetry or Prometheus histograms: capture start time (`t0 := time.Now()`), defer `hist.Observe(time.Since(t0).Seconds())`. Use low‑overhead, non‑blocking metrics libraries.|
|58|What is **`context.WithValue`** and why should its use be limited?|Stores key‑value pairs in a context. It is meant for request‑scoped data crossing API boundaries (e.g., trace IDs). Overusing it for passing arbitrary data breaks type safety and can cause memory leaks if large objects are stored.|
|59|Explain **`runtime.LockOSThread()`**. When is it necessary?|Locks the current goroutine to its current OS thread. Required when interacting with thread‑local state, C libraries that require a specific OS thread, or when using OpenGL / GPU contexts.|
|60|What is the **“fan‑in”** pattern for aggregating results from many goroutines?|Create a result channel; each worker sends its result to the channel. The aggregator ranges over the channel and collects results until all workers are done (close channel after `WaitGroup`).|

---

## 3️⃣ Distributed Architecture & Design Patterns (25)

| # | Question | Answer |
|---|----------|--------|
|61|Define **CAP theorem** and its implications for a trading engine.|CAP states that a distributed system can provide at most two of Consistency, Availability, Partition tolerance. A trading engine usually prioritizes **Consistency** (order match correctness) and **Partition tolerance**, sacrificing strict availability during network partitions (e.g., by halting new orders).|
|62|Explain the **event‑sourcing** pattern and how it fits blockchain‑style systems.|All state changes are stored as an immutable sequence of events. The current state can be rebuilt by replaying events. Blockchain naturally implements event‑sourcing: each transaction is an event, hashed together to guarantee immutability.|
|63|What is a **CQRS** (Command Query Responsibility Segregation) architecture?|Separates write (command) models from read (query) models. Commands validate & produce events; queries read from materialized views optimized for read patterns. In a trading platform, writes update order books, while queries serve market data from a denormalized cache.|
|64|What is the role of a **message broker** (Kafka, NATS, RabbitMQ) in a high‑throughput trading system?|Provides durable, ordered, and scalable pub/sub pipelines for order events, market data, risk checks, and settlement. Enables decoupling of services, allows replay, and supports back‑pressure handling.|
|65|How would you design a **sharded order‑book** service to handle millions of symbols?|Partition by symbol (or by hash of symbol) into shards. Each shard runs its own order‑matching engine and persists to its own MySQL instance or RocksDB. Use consistent hashing for routing, and a lightweight meta‑service for shard lookup.|
|66|What is **consistent hashing** and why is it useful for cross‑chain payment routing?|Maps keys (e.g., payment IDs) onto a ring of nodes; each node owns a range of hash values. Adding/removing nodes only re‑maps a small fraction of keys, reducing data movement. Useful when routing payments across a dynamic set of blockchain bridges.|
|67|Explain **leader election** in a cluster (e.g., using Raft).|Nodes exchange heartbeats; the candidate with the highest term that gathers a majority of votes becomes leader. Leader handles writes, replicates log entries to followers, and ensures consistency. Raft simplifies implementation vs. Paxos.|
|68|What are the **trade‑offs** between **synchronous** vs **asynchronous** RPC in a microservice architecture?|Synchronous RPC provides immediate response, easier to reason about, but can cause cascading latency and coupling. Asynchronous messaging decouples services, improves resilience, but introduces eventual consistency and requires correlation IDs for tracing.|
|69|How does **gRPC** differ from **REST/JSON** in high‑performance services?|gRPC uses HTTP/2, binary Protobuf payloads (smaller, faster), supports streaming bi‑directionally, and provides built‑in code generation for typed contracts, reducing serialization overhead compared to JSON.|
|70|What is **service mesh** (e.g., Istio) and does a trading engine need it?|A dedicated infrastructure layer for service‑to‑service communication, handling traffic routing, retries, circuit breaking, and observability. It can help with security (mTLS) and telemetry, but adds complexity; for latency‑critical paths, a lightweight custom solution may be preferable.|
|71|Describe **idempotency** in API design. How would you guarantee it for order placement?|Idempotency ensures that repeated identical requests have the same effect as a single request. Use a client‑generated idempotency key stored with the order; on repeat, return the existing order instead of creating a new one.|
|72|What is a **distributed transaction** and why is it often avoided in blockchain‑related systems?|A transaction spanning multiple nodes that must either commit everywhere or abort everywhere (e.g., 2‑PC). It requires coordination and can be a bottleneck. Blockchain systems favor eventual consistency and rely on atomic on‑chain transactions instead.|
|73|Explain the **Saga pattern** and a scenario where it applies to cross‑chain payments.|Long‑running business process composed of a series of local transactions each with a compensating action. In cross‑chain payment, lock funds on source chain, initiate transfer, and upon failure, run compensating transaction to unlock the funds.|
|74|How would you **scale read‑heavy market‑data queries**?|Introduce a read‑replica layer (MySQL read replicas or a distributed cache like Redis), employ a CDN for static data, and materialize denormalized tables (e.g., per‑symbol price history). Use cache‑aside pattern with cache invalidation on updates.|
|75|What is **cache‑aside vs write‑through** caching? Which fits a real‑time order‑book?|Cache‑aside: application reads from cache, on miss loads from DB, writes update DB then invalidate cache. Write‑through: writes go to both cache and DB synchronously. For an order‑book needing ultra‑low latency, write‑through to an in‑memory store (Redis) plus eventual persistence is common.|
|76|Explain **partition tolerance** and why it is mandatory for blockchain nodes.|System must continue operating despite network partitions. Nodes must be able to accept transactions and produce blocks independently, later reconciling via consensus (e.g., PoW, PoS).|
|77|What is a **cold‑start problem** in microservices and how to mitigate it?|First request incurs high latency due to initialization (e.g., loading configs, compiling contracts). Mitigate with warm‑up probes, keep‑alive containers, pre‑compiled artifacts, and lazy loading of rarely‑used modules.|
|78|How does **bulkhead isolation** improve system resilience?|Divides resources (threads, connections, goroutine pools) into separate compartments so that failure in one component doesn’t exhaust resources for the whole system. Implement via separate connection pools or rate limiters per service.|
|79|What does **“eventual consistency”** mean? Give an example in a blockchain gateway.|Data replicas may temporarily diverge; they will converge given no new updates. Example: a payment status cached in Redis may be stale for a few seconds until the sync job pulls the latest on‑chain state.|
|80|Why is **observability** (metrics, logs, traces) critical for a trading engine?|Real‑time financial systems must detect latency spikes, order mismatches, and failures instantly. Observability enables SLA monitoring, root‑cause analysis, and compliance auditing.|
|81|What are **side‑chains** and how can they be used for cross‑chain payments?|Independent blockchains that are interoperable with a main chain via a two‑way peg. Payments can be transferred to a side‑chain for faster settlement and then back‑to‑main‑chain, reducing fees and latency.|
|82|Define **“high availability”** in the context of a matching engine.|Guarantees that order matching continues with minimal downtime (< seconds). Achieved via active‑active deployment, automatic fail‑over, state replication (e.g., using Raft), and health‑checking load balancers.|
|83|What is **“back‑pressure”** in a stream processing pipeline?|When downstream components cannot keep up, upstream producers slow down (or stop) to avoid unbounded buffering. In Go, you achieve this via bounded channels or reactive streams that propagate `request(N)` signals.|
|84|Explain **Zero‑knowledge proofs (ZK‑SNARKs)** in a blockchain context.|Cryptographic proofs that demonstrate knowledge of a secret (e.g., transaction validity) without revealing it. Used for privacy‑preserving transactions and scalable verification on-chain (e.g., zk‑Rollups).|
|85|How would you **handle hot‑keys** (e.g., a single token with massive trade volume) in a sharded system?|Detect hot‑keys via metrics, then apply **adaptive sharding**: split the hot key into sub‑partitions (e.g., by price level) or route its traffic to a dedicated node with higher capacity. Use consistent hashing with virtual nodes.|
|86|What is the **“fall‑through”** pattern in API gateways?|A request that does not match any specific route is forwarded to a default backend (e.g., a generic handler). Useful for versioning and supporting legacy endpoints.|
|87|Explain **“chaos engineering”** and a simple experiment you could run on a matching engine.|Deliberately inject failures (e.g., kill a node, add latency) to validate system resilience. Example: randomly pause order‑matching goroutine for 100 ms and verify that the system still meets latency SLA via fallback nodes.|
|88|What are **“cold‑reads”** vs **“warm‑reads”** in a cache, and why do they matter?|Cold‑reads miss the cache, requiring DB fetch; warm‑reads hit the cache, delivering low latency. Minimizing cold‑reads reduces DB load and improves user experience.|
|89|How does **BFT (Byzantine Fault Tolerance)** differ from classic quorum consensus?|BFT tolerates up to *f* compromised nodes out of *3f+1* total, handling arbitrary (malicious) failures, whereas classic quorum (e.g., Raft) only tolerates crash failures. BFT is necessary for permissioned blockchains.|
|90|When would you use **CQRS + Event Sourcing** vs a simple CRUD service?|When write throughput is high and you need an immutable audit trail (e.g., order events). Event sourcing enables replay for debugging and compliance. CRUD is sufficient for simple, low‑traffic services.|
|91|Describe **transactional outbox pattern** and its relevance to cross‑chain payments.|Writes a record of the outbound message in the same DB transaction that updates business state, then a separate process reads the outbox and sends the message (e.g., to a bridge). Guarantees exactly‑once delivery despite failures.|
|92|What is a **“read‑repair”** mechanism in distributed key‑value stores?|When a read request discovers a stale replica, the node initiates a background write to update the stale copy, ensuring eventual consistency.|
|93|Explain the concept of **“state channels”** and a scenario where they improve scalability.|Off‑chain bilateral channels where parties exchange signed messages representing state updates. Final state is settled on‑chain. Useful for high‑frequency micro‑payments (e.g., gaming) without flooding the main chain.|
|94|How would you **monitor and alert** on order‑matching latency breaches?|Collect latency histogram metrics with Prometheus (`order_match_latency_seconds`). Set alert rule: `histogram_quantile(0.95, rate(order_match_latency_seconds_bucket[5m])) > 100ms`. Route alerts to PagerDuty.|
|95|What is **“idempotent consumer”** in a message‑driven system?|A consumer that can process the same message multiple times without adverse effects (e.g., by using a deduplication key or checking if the operation already exists). Essential for at‑least‑once delivery guarantees.|
|96|Define **“eventual consistency window”** and its acceptable size for a payment gateway.|The time between a state change on one node and its visibility on all others. For payments, the window should be sub‑second to seconds to meet user expectations and regulatory requirements.|
|97|Explain **“sharding” vs “partitioning”**. Are they the same?|Both split data, but sharding is a **horizontal** distribution across multiple independent nodes (often with separate DB instances). Partitioning can be logical within a single DB (e.g., MySQL partition tables).|
|98|What is **“leader‑follower replication”** and its impact on read latency?|Writes go to the leader; followers asynchronously replicate. Reads can be served from followers, reducing latency and load on the leader, but may return slightly stale data.|
|99|How would you **design a graceful degradation** strategy for market‑data feeds under load?|Prioritize critical feeds (e.g., top 10 symbols) and drop lower‑priority ones. Throttle updates, reduce frequency, or switch to cached snapshots. Communicate degraded status via health endpoint.|
|100|What is **“hot‑standby”** vs **“active‑active”** deployment?|Hot‑standby: standby node runs idle, ready to take over on failure. Active‑active: multiple nodes serve traffic simultaneously, sharing load. Active‑active offers higher capacity but requires conflict resolution.|
|101|Explain **“zero‑downtime deployment”** using blue‑green or canary strategies.|Blue‑green: two identical production environments; traffic switched to new version after health checks. Canary: roll out to a small subset of users, monitor, then expand. Both avoid service interruption.|
|102|Why is **determinism** essential for a blockchain's consensus algorithm?|All nodes must compute the same result for the same input to reach agreement. Non‑deterministic code (e.g., using timestamps) would cause forks.|
|103|How do **Merkle trees** help verify data integrity in a distributed ledger?|Leaves contain hashes of transactions; internal nodes hash concatenated child hashes, culminating in a root hash. A proof (Merkle path) demonstrates inclusion of a transaction without revealing the whole dataset.|
|104|What is **“cross‑shard communication”** and how can it be achieved?|Interaction between shards (e.g., transferring tokens). Approaches: atomic commit protocols, relay chains, or inter‑shard transaction queues with validators that certify state changes.|
|105|Define **“gossip protocol”** and its use in blockchain networks.|Peers periodically exchange information about known peers and blocks, ensuring eventual propagation of transactions across the network without a central coordinator.|

---

## 4️⃣ Trading Engine Fundamentals (20)

| # | Question | Answer |
|---|----------|--------|
|106|What are the **four basic order types** supported by most exchanges?|Market, Limit, Stop (Stop‑Loss), and Stop‑Limit. Variants include IOC (Immediate‑Or‑Cancel), FOK (Fill‑Or‑Kill), and GTC (Good‑Till‑Cancelled).|
|107|Explain the **price‑time priority** matching rule.|Orders are matched first by best price (higher for bids, lower for asks). Within the same price level, earlier timestamps receive priority.|
|108|How would you implement an **order book** data structure in Go for high‑frequency matching?|Use a **skip‑list** or **red‑black tree** (e.g., `container/heap` for price levels) for O(log n) insertion/removal, plus a linked list for FIFO ordering within each price level.|
|109|What is the difference between **limit order book** and **order‑matching engine**?|Limit order book stores resting orders; the matching engine contains the logic that consumes incoming orders, updates the book, and generates trades.|
|110|Describe the **cross‑matching** process for a market order.|Market order traverses price levels from best to worst, matching with available volume until fully filled or the book is exhausted. Remaining unfilled volume may be rejected or placed as a market‑on‑close order.|
|111|How would you **prevent double‑spending** in an off‑chain matching engine?|Maintain a **nonce** or **sequence number** per account and enforce that each order consumes the correct available balance. Use atomic DB transactions or in‑memory lock per account.|
|112|Explain **order‑book snapshot vs incremental updates** for market data feeds.|Snapshot: full state of the order book (price levels & quantities). Incremental updates: only changes (new orders, cancellations, trades). Incremental updates reduce bandwidth but require the client to apply them correctly based on a prior snapshot.|
|113|What is **latency‑sensitivity** in a matching engine, and how to mitigate it?|Small delays directly affect order execution quality. Mitigate by using in‑memory data structures, lock‑free algorithms, CPU pinning, low‑latency networking (e.g., kernel bypass, DPDK), and avoiding GC spikes (pre‑allocate objects).|
|114|How do you **handle order cancellations** that arrive concurrently with matching?|Use per‑order or per‑price‑level locks, or lock‑free atomic state flags (`status` field). When processing a cancel, atomically set the flag; matching goroutine checks the flag before filling.|
|115|Explain **order‑matching fairness** when multiple identical orders exist.|Enforce strict FIFO at the same price level; use timestamp or sequence numbers from the client that cannot be spoofed.|
|116|What is a **self‑trade** and why must an exchange prevent it?|When a user's own buy and sell orders match against each other, possibly inflating volume or manipulating price. Prevent by checking user IDs before matching and rejecting matches that involve the same participant.|
|117|How would you **scale** the order‑matching engine horizontally?|Partition by symbol or market, run multiple independent matching instances per partition, and use a **matching coordinator** for cross‑symbol orders (e.g., basket trades). Use a deterministic sharding scheme to route orders consistently.|
|118|Describe **risk checks** that must run before an order is accepted.|Balance verification, position limits, exposure limits, AML/KYC checks, order size limits, and margin checks for leveraged trading.|
|119|What is the **“maker‑taker”** fee model?|Makers provide liquidity (resting orders) and receive a rebate; takers remove liquidity (market orders) and pay a fee. The engine must correctly label each trade as maker or taker.|
|120|How would you **audit** trade execution for compliance?|Maintain an immutable log of order submissions, state changes, and trade events (e.g., append‑only log, signed records). Enable query by order ID, timestamp, and produce regular reconciliation reports.|
|121|Explain the concept of **“order aggregation”** (e.g., iceberg orders).|Large orders are split into smaller visible slices to hide true size. The engine maintains a hidden quantity field and reveals the next slice only after the current one is filled.|
|122|What is **“post‑only”** order behavior?|Ensures the order will not immediately match; it is placed only if it adds liquidity. If it would match on entry, it is rejected. Useful for guaranteed maker fees.|
|123|How do you **prevent race conditions** on the same account's balance in a concurrent engine?|Serialize all operations affecting a single account using a per‑account mutex or an atomic CAS loop on the balance field. Alternatively, employ an optimistic concurrency control with version numbers.|
|124|What is an **“order book depth”** and why is it important for traders?|Depth shows the cumulative quantity available at each price level (e.g., top 10 bids/asks). Traders use it to assess market liquidity and slippage risk.|
|125|Explain **“partial fills”** and how you would represent them.|When an order matches only a portion of its quantity, the remaining quantity stays in the book. Represent each order with fields: `totalQty`, `filledQty`, `remaining = total - filled`.|
|126|What is a **“matching engine latency budget”** and typical numbers for a crypto exchange?|Target end‑to‑end latency from order receipt to confirmation, often ≤ 1 ms for top‑tier exchanges; budget split among network I/O, deserialization, matching logic, and persistence.|
|127|How would you **persist** order‑book state for crash recovery?|Write periodic checkpoints (e.g., every 100 ms) to durable storage (RocksDB, MySQL with binary logs) and also maintain an append‑only log of every order event. On restart, load checkpoint then replay logs.|
|128|Describe **“circuit breaker”** behavior for incoming order flow in case of overload.|Monitor inbound order rate; if it exceeds a threshold, temporarily reject new orders (return 429) or drop to a lower‑priority queue. Auto‑recover when rate falls below a hysteresis level.|
|129|What is **“order idempotency”** and how does it differ from request idempotency?|Order idempotency ensures that re‑submitting the same order (same client‑generated ID) does not create duplicate orders. Request idempotency is broader, covering any API call.|
|130|Explain **“price bands”** or **circuit breakers** used by exchanges during extreme volatility.|A mechanism that pauses trading or widens the minimum tick size when price moves excessively within a short window, protecting market integrity.|
|131|How would you **test** the matching engine for correctness under high load?|Use property‑based testing (e.g., `gopter`), generate random order streams, simulate a reference implementation, compare results. Also run stress tests with millions of orders using `go test -run Benchmark` and verify order‑book invariants.|
|132|What is the **“trade‑through”** problem and how can you detect it?|A trade occurs at a price worse than the best available price (e.g., hidden liquidity). Detect by checking that executed price is always within the best bid/ask at the time of execution.|
|133|Explain **“settlement”** vs **“matching”** in a trading system.|Matching creates a trade record; settlement moves assets (on‑chain or off‑chain). Matching is instantaneous; settlement may be asynchronous (e.g., withdrawal to blockchain).|
|134|How do you **handle currency conversion** for cross‑pair orders?|Maintain an internal reference price (e.g., oracle) and convert order quantities to a base currency before matching, or execute a two‑leg trade using an internal market maker.|
|135|What are **“order flow toxicity”** metrics and why are they tracked?|Measures the proportion of informed vs uninformed orders (e.g., adverse selection). High toxicity may trigger tighter spreads or reduced maker rebates.|
|136|Describe **“order expiration”** handling (e.g., GTC vs Day orders).|Orders carry an expiration timestamp or a `TimeInForce` flag; a background sweeper deletes or cancels expired orders, ensuring they don’t linger in the book.|
|137|What is a **“liquidity pool”** and how does it differ from an order book?|Liquidity pool uses an automated market maker (AMM) with a pricing curve (e.g., constant product) rather than discrete limit orders. No order book; price is derived from pool balances.|
|138|Explain the **“price impact”** of a large order. How can a matching engine mitigate it?|Large orders can move the market price by consuming multiple price levels. Mitigation: split orders (iceberg), use time‑weighted average price (TWAP) algorithms, or provide hidden orders.|
|139|What is a **“trade reconciliation”** process?|Periodically compare internal trade logs with external settlement records (e.g., blockchain receipts) to ensure all trades are accounted for and no mismatches exist.|
|140|How would you **ensure deterministic** order matching across multiple replica nodes?|Use the same deterministic algorithm, process orders in the exact same sequence (e.g., via a globally ordered log like Kafka), and avoid non‑deterministic sources (e.g., `time.Now`).|

---

## 5️⃣ Cross‑Chain Payments & Interoperability (15)

| # | Question | Answer |
|---|----------|--------|
|141|What is a **bridge** in blockchain terminology?|A set of smart contracts and off‑chain relayers that lock assets on a source chain and mint corresponding wrapped assets on a destination chain, enabling transfer of value across chains.|
|142|Explain **HTLC (Hashed Time‑Lock Contract)** and its role in atomic swaps.|Two contracts on different chains lock funds and require the same secret pre‑image to claim. The time‑lock ensures that if the secret isn’t revealed, funds are refunded after expiry, guaranteeing atomicity.|
|143|What are **oracles** and why are they critical for cross‑chain transactions?|Oracles provide external data (e.g., price feeds, event proofs) to smart contracts. For cross‑chain payments, they confirm that a lock event occurred on the source chain before minting on the destination.|
|144|Define **finality** in blockchain and the difference between **probabilistic** and **deterministic** finality.|Finality is the guarantee that a transaction cannot be reverted. Probabilistic (PoW) finality grows with more confirmations; deterministic (PoS/BFT) finality is achieved after a consensus step.|
|145|What is a **state channel** and how does it enable fast cross‑chain payments?|Off‑chain channel where participants exchange signed state updates; only the final state is submitted on‑chain. Payments can be settled instantly off‑chain and later anchored on the main chain, reducing latency and fees.|
|146|Explain **two‑way peg** versus **one‑way peg**.|Two‑way peg allows assets to move both directions (e.g., BTC ↔ wBTC). One‑way peg only allows minting on the destination chain; burning or redeeming back to the source is not supported.|
|147|What is a **Merkle proof** and how is it used in cross‑chain verification?|A path of sibling hashes from a leaf to the Merkle root; proves inclusion of a transaction without exposing the entire block. Relayers submit Merkle proofs to verify that a lock transaction happened on the source chain.|
|148|Describe the **“relay”** approach for cross‑chain communication.|One chain runs a light client (or full node) of another chain, verifying blocks and events internally, then exposing them via smart contracts. E.g., Ethereum ↔ Cosmos IBC relay.|
|149|What are **optimistic rollups** and can they be used for cross‑chain payments?|Layer‑2 solutions that post transaction data on‑chain and assume correct execution, with fraud proofs for disputes. They can act as a bridge by posting proofs of lock events to the destination chain.|
|150|Explain **“atomic cross‑chain transaction”** and the challenges in achieving it.|A transaction that either completes on all involved chains or none. Challenges: different consensus models, latency, finality differences, and the need for cryptographic proofs or multi‑sig escrow.|
|151|How would you **ensure replay protection** for a transaction that moves across chains?|Include a unique nonce or chain‑specific identifier in the signed payload, and have the destination contract reject any transaction whose nonce has already been used.|
|152|What is **IBC (Inter‑Blockchain Communication)** and its core components?|A protocol for sovereign blockchains to send packets across. Core components: **Clients** (light client of the counterparty), **Connections**, **Channels**, and **Packets**.|
|153|Give an example of a **cross‑chain payment workflow** using HTLC.|1. Alice creates HTLC on Chain A locking X tokens, shares hash `h`. 2. Bob creates HTLC on Chain B locking Y tokens with same `h`. 3. Alice reveals pre‑image `s` to claim Y on B. 4. Bob learns `s` and claims X on A. Both swaps are atomic.|
|154|What is **“watchtower”** in the context of cross‑chain bridges?|An off‑chain service that monitors source chain events and submits proofs to the destination chain on behalf of users (e.g., to claim wrapped assets), improving reliability and user experience.|
|155|How can **threshold signatures** improve security of cross‑chain bridges?|Funds are locked using a multi‑sig (e.g., 2‑of‑3) where the signing keys are distributed across independent operators. Compromise of a single node does not allow unauthorized minting.|
|156|What is **“liquidity bootstrapping”** for a new cross‑chain asset?|Providing initial liquidity via incentives (e.g., farming rewards) or using a central bridge operator to ensure that users can swap the newly minted wrapped asset without large price impact.|
|157|Explain **“proof‑of‑authority”** vs **“proof‑of‑stake”** and their relevance for cross‑chain validators.|PoA relies on a set of known validators, offering high throughput and low latency; PoS selects validators based on stake, providing decentralization. For bridges, PoA validators can quickly sign proofs, while PoS ensures broader security.|
|158|What is a **“gateway”** contract and how does it differ from a bridge contract?|Gateway contracts handle user interaction (deposit/withdraw) and may delegate verification to separate validator contracts, whereas a bridge contract directly contains the verification logic.|
|159|How would you **handle fee accumulation** in a cross‑chain payment system?|Collect fees in the source chain during lock, mint a proportional amount of “bridge fee token,” or allocate fees to a dedicated contract that distributes rewards to relayers/validators.|
|160|What are **“fallback mechanisms”** if a cross‑chain transaction fails?|Timeout‑based refunds (HTLC expiry), manual dispute resolution via governance, or a “force‑unlock” mechanism that requires a super‑majority of validators to approve.|
|161|Explain **“on‑chain governance”** for upgrading bridge smart contracts.|Governance token holders vote on proposals; if passed, a pre‑defined upgrade path (e.g., proxy pattern) activates a new implementation contract. This allows patches without breaking existing assets.|
|162|What is **“cross‑chain atomicity”** vs **“eventual consistency”**?|Atomicity guarantees all‑or‑nothing across chains; eventual consistency allows temporary divergence with later reconciliation (e.g., when using optimistic rollups).|
|163|How does **“finality gadget”** (e.g., Casper) help in cross‑chain proofs?|It provides a deterministic finality point on a probabilistic chain, allowing other chains to safely accept a block as final after the gadget signals, reducing the confirmation window needed for HTLCs.|
|164|Give a **high‑level diagram** of a cross‑chain swap using a **relayer network**.|User → Source‑Chain HTLC (lock) → Relayer observes event, submits Merkle proof + pre‑image to Destination‑Chain HTLC (claim) → Destination‑Chain releases tokens → Relayer extracts pre‑image and forwards to source for the opposite claim.|
|165|What security issues arise from **centralized bridges**?|Single point of failure, custodial risk, potential for censorship, and the need for external audits. Decentralized bridges mitigate these via multi‑sig, fraud proofs, and open validator sets.|
|166|How would you **test** a cross‑chain bridge implementation?|Unit test each contract with Hardhat/Foundry, integration tests using testnets (e.g., Ropsten ↔ BSC testnet), fuzzing of HTLC parameters, and end‑to‑end simulation with a local multi‑node environment (e.g., Ganache + Geth).|
|167|What is **“replay attack”** in cross‑chain contexts and how to prevent it?|Re‑submitting a previously valid transaction on another chain. Mitigation: include chain ID, unique nonce, and enforce one‑time use of proofs in destination contracts.|
|168|Explain **“Merkle‑Patricia Trie”** and its role in Ethereum proof generation.|A Patricia trie stores key‑value pairs (e.g., account states) with cryptographic hashing at each node. Merkle proofs consist of sibling nodes along the path, allowing verification of a specific account’s state against the block header root hash.|
|169|What is **“cross‑chain liquidity aggregation”** and why is it beneficial?|Combining liquidity from multiple bridges/DEXs into a single interface, allowing users to obtain the best rate and deeper depth, leading to reduced slippage and higher throughput.|
|170|Describe **“optimistic bridging”** and its risk mitigation.|Bridges assume transactions are valid and allow withdrawals instantly, but keep a fraud proof window where validators can challenge. If a fraud proof succeeds, the withdrawer is slashed. This reduces latency while preserving security.|
|171|How would you **handle token decimals** when moving assets across chains with different precision?|Normalize to a common base (e.g., 18 decimals) on the source, store the original decimals in metadata, and adjust conversion on the destination (e.g., `amount * 10^(destDecimals - srcDecimals)`).|
|172|What is a **“wrapped token”** and how does it maintain 1:1 peg?|A token that represents an asset locked on another chain. The bridge contract holds the original asset and mints a corresponding amount of the wrapped token; redemption burns the wrapped token and releases the original asset.|
|173|Explain **“state proof”** vs **“transaction proof”** for cross‑chain verification.|State proof demonstrates that a particular storage slot (e.g., balance) has a specific value at a given block. Transaction proof shows that a transaction was included in a block. Both are needed when verifying complex actions.|
|174|What is **“validator slashing”** and how does it protect a bridge?|If a validator signs an invalid proof or misbehaves (double‑signing, downtime), they lose a portion of their stake. This economic penalty deters malicious actions and incentivizes honest participation.|
|175|How can **“layer‑2 rollups”** be used as a bridge to a layer‑1 chain?|Rollup contracts post state roots on L1; L2 participants can submit proofs to L1 to claim assets, effectively moving value from L2 to L1 via a trustless bridge.|
|176|What is **“gas abstraction”** and why is it relevant for cross‑chain contracts?|Allowing contracts to pay gas fees in tokens other than the native coin (e.g., ERC‑20). In cross‑chain scenarios, a relayer can sponsor gas on the destination chain, improving UX.|
|177|What are **“bridging fees”** and how are they typically calculated?|A percentage of the transferred amount plus a fixed gas cost. Some bridges use dynamic fees based on network congestion or the amount of liquidity consumed.|
|178|Explain **“fallback function”** in Solidity and its role in a bridge contract.|A special `receive`/`fallback` function that is invoked when no other function matches. Used to accept direct Ether transfers or to handle unknown method calls, often logging events for off‑chain relayers.|
|179|How would you **detect** a malicious relayer that submits false proofs?|Validate proofs on‑chain using cryptographic verification (Merkle, SNARK). Additionally, require multi‑sig confirmation from a quorum of validators; any relayer acting alone cannot succeed.|
|180|What is **“cross‑chain atomic swap”** vs **“cross‑chain payment”**?|Atomic swap exchanges two assets directly (e.g., BTC ↔ ETH) without a third‑party intermediary. Cross‑chain payment typically moves a single asset from one chain to another (e.g., BTC → wBTC).|
|181|Give an example of a **use case** for cross‑chain payments in DeFi.|A user wants to provide liquidity on an Ethereum‑based DEX but holds USDT on the Binance Smart Chain; they lock USDT on BSC, receive wrapped USDT (wUSDT) on Ethereum, then add it to the pool, all in a single atomic operation.|
|182|What is **“bridge federation”** and how does it differ from a **validator set**?|Federation is a small, known group of entities managing the bridge (often with custodial rights). A validator set can be permissionless and may use staking to join. Federation is more centralized, validator sets are more decentralized.|
|183|How does **“state synchronization”** differ from block synchronization?|State sync pulls only the latest state (e.g., account balances) without replaying every block, enabling fast node boot‑strapping. Useful for relayers that only need proofs of specific events.|
|184|What are **“relay contracts”** and why might you separate them from core bridge logic?|Relay contracts only forward verified proofs to the core contract. Separation makes upgrades easier, isolates security‑critical verification, and allows multiple relayers to interact with a single trusted core.|
|185|Explain **“cross‑chain order book”** concept.|A shared order book where orders placed on one chain are visible to users on other chains, possibly via a bridge that syncs order events. Helps liquidity aggregation across ecosystems.|
|186|What is **“on‑chain randomness”** (e.g., VRF) and how could it be used in cross‑chain protocols?|Verifiable Random Function provides provably random numbers on‑chain. Can be used to select relayers, generate unique nonces, or randomize validator assignment to improve security.|
|187|Describe **“fallback withdrawal”** in an HTLC that expires without being claimed.|If the timeout expires and the receiver never provided the pre‑image, the original sender can invoke a refund function on the source HTLC, which unlocks the locked funds.|
|188|What is **“proof‑of‑authority bridge”** and its typical use‑case?|A bridge where a set of known authorities validate events and sign proofs. Used when low latency and high throughput are required, such as linking a private consortium chain to a public chain.|
|189|How would you **ensure compatibility** with future protocol upgrades on both source and destination chains?|Design bridge contracts to be upgradeable (proxy pattern) and include versioning in the proof format. Off‑chain relayers should be modular to support new proof schemas.|
|190|What is **“layer‑0”** (e.g., Polkadot) and how does it facilitate cross‑chain payments?|Layer‑0 provides a shared security and messaging layer (relay chain) that allows parachains to send messages and assets to each other via **XCMP** (Cross‑Chain Message Passing), enabling seamless token transfers.|
|191|How does **“transaction replay protection”** differ between Ethereum and Bitcoin?|Ethereum includes `chainId` in the transaction signature (EIP‑155), preventing replay across networks. Bitcoin lacks a chain identifier; replay protection must be built into scripts (e.g., using locktime).|
|192|What are **“wrapped NFTs”** and can they be transferred across chains?|An NFT locked on one chain, with a corresponding ERC‑721 token minted on another chain representing ownership. Transfer follows the same lock‑mint‑burn‑unlock flow as wrapped fungible tokens.|
|193|Explain the role of **“event listeners”** in a bridge architecture.|Off‑chain services that subscribe to blockchain events (via websockets, RPC, or logs) and trigger actions such as generating proofs, updating off‑chain state, or notifying users.|
|194|What is **“gas estimation”** and why is it critical for cross‑chain minting transactions?|Estimating the amount of gas needed to successfully execute a transaction on the destination chain prevents out‑of‑gas failures, which would otherwise lock assets. Accurate estimation reduces user friction and fees.|
|195|How would you **handle transaction reorgs** on the source chain when a lock event is reverted?|Wait for a sufficient number of confirmations before accepting the lock (e.g., 12 blocks). If a reorg occurs before finality, the bridge discards the pending proof and refunds the user.|
|196|What is a **“bridge escrow”** and how does it secure assets?|An escrow contract holds locked assets on the source chain; it only releases them when a valid proof of corresponding mint on the destination chain is presented, ensuring that assets cannot be double‑spent.|
|197|Explain **“cross‑chain governance voting”** and a possible implementation.|Users on multiple chains can vote on proposals by submitting signed votes to a bridge contract that aggregates them. The bridge forwards the final tally to each chain’s governance module.|
|198|What is **“gas‑price oracle”** and why might a bridge need one?|Provides the current gas price on a destination chain so the bridge can set appropriate fees for relayers and users. Prevents under‑paying (stuck tx) or over‑paying (excess fees).|
|199|How do **“multi‑sig wallets”** improve security of bridge treasury contracts?|Funds require signatures from several distinct keys before a transfer can be executed, reducing the risk of a single compromised key stealing assets.|
|200|Give a high‑level **step‑by‑step flow** for a user moving USDT from BSC to Ethereum using a bridge with validators.|1. User calls `deposit(amount)` on BSC bridge contract. 2. Contract locks USDT and emits `Deposit` event. 3. Validators observe event, generate Merkle proof and sign it. 4. User (or relayer) submits signed proof to Ethereum bridge contract. 5. Proof is verified; contract mints equivalent wUSDT on Ethereum. 6. User can now use wUSDT on Ethereum. 7. To reverse, user burns wUSDT, validators submit proof to BSC contract, which releases original USDT.|

---

## 6️⃣ MySQL (15)

| # | Question | Answer |
|---|----------|--------|
|201|What is the **difference** between **InnoDB** and **MyISAM** storage engines?|InnoDB supports ACID transactions, row‑level locking, foreign keys, and crash recovery. MyISAM is non‑transactional, uses table‑level locking, and is faster for read‑only workloads. In financial systems you always use InnoDB.|
|202|Explain **ACID** properties and why each is crucial for order matching.|Atomicity – each transaction fully applies or rolls back. Consistency – DB moves from one valid state to another (e.g., balances stay non‑negative). Isolation – concurrent transactions don’t interfere (use REPEATABLE READ). Durability – once committed, data survives crashes.|
|203|What isolation level does InnoDB use by default, and is it sufficient for a trading engine?|`REPEATABLE READ`. It prevents non‑repeatable reads and phantom reads via MVCC, which is generally sufficient, but for strict order of updates you might need `SERIALIZABLE` or explicit locking (`SELECT … FOR UPDATE`).|
|204|How would you **prevent duplicate order IDs** in a highly concurrent environment?|Define the `order_id` column as `PRIMARY KEY` (or `UNIQUE`). Insertion attempts that conflict will return a duplicate‑key error, which can be caught and handled (e.g., retry with a new ID).|
|205|Explain **optimistic vs pessimistic locking** and when to use each.|Optimistic assumes low contention: read data, verify version/timestamp on update. Pessimistic acquires a lock (`SELECT … FOR UPDATE`) before modification. Use optimistic for read‑heavy workloads; pessimistic for high‑contention balances/orders.|
|206|What is a **transaction deadlock**, how does MySQL detect it, and how can you avoid it?|Two transactions wait for each other’s locks, forming a cycle. InnoDB detects deadlocks via the lock‑wait graph and aborts one transaction (error 1213). Avoid by acquiring locks in a consistent order and keeping transactions short.|
|207|How do you **store high‑precision decimal amounts** (e.g., token amounts) safely?|Use the `DECIMAL(p, s)` type (e.g., `DECIMAL(38,18)`) to store fixed‑point numbers with up to 18 decimal places, avoiding floating‑point rounding errors.|
|208|Explain **binary logs** (`binlog`) and their role in replication.|`binlog` records all data‑changing statements (statement‑based) or row images (row‑based). Slaves read the binlog to replay changes, keeping them in sync. Essential for high availability and disaster recovery.|
|209|What is **row‑based replication** vs **statement‑based**? Which is preferred for financial data?|Row‑based logs the actual row changes, guaranteeing identical results on slaves. Statement‑based logs the SQL statements. Row‑based is preferred for deterministic replication of complex financial updates.|
|210|How would you **scale reads** for market data queries?|Deploy read replicas, use a load balancer, and route read‑only queries to replicas. Ensure replication lag is acceptable (e.g., sub‑second) for near‑real‑time data.|
|211|What is an **index**, and which types are most suitable for order‑book queries?|An index is a data structure that speeds up look‑ups. For order books, composite indexes on `(symbol, price, timestamp)` or `(symbol, side, price)` support range scans for best bid/ask. Use **B‑tree** (default) for ordered range queries.|
|212|Explain **covering indexes** and their performance benefit.|A covering index contains all columns required by a query, so the engine can satisfy the query using only the index without hitting the table rows, reducing I/O. Helpful for frequently run simple market‑data queries.|
|213|What is **partitioning** in MySQL and how could it help a high‑volume trade table?|Divides a large table into smaller, manageable pieces (by RANGE, LIST, HASH, or KEY). For a trade table, partition by date (e.g., daily) enables fast pruning of historical data and faster archiving.|
|214|How do you **detect and resolve long‑running queries** that affect latency?|Enable the performance schema, use `SHOW PROCESSLIST`, set `slow_query_log` with threshold (e.g., 100 ms). Optimize via indexes, query rewriting, or breaking large queries into smaller batches.|
|215|What is **foreign key** usage in a financial database, and should you always use it?|Enforces referential integrity (e.g., `orders.user_id` → `users.id`). Useful for data consistency, but can add overhead on inserts/updates. In high‑throughput trading, sometimes denormalize and validate at the application layer for speed.|
|216|Explain **transaction log (redo log)** and its importance for durability.|Redo logs store changes before they are flushed to the data files. In a crash, the engine replays the redo log to bring the DB to a consistent state, guaranteeing durability of committed transactions.|
|217|What is **`SELECT … FOR UPDATE`** and when would you use it?|Locks the selected rows for update within the current transaction, preventing other transactions from acquiring conflicting locks. Use when you need to read‑modify‑write a balance atomically.|
|218|How would you **implement a “soft delete”** for auditability?|Add a boolean column `deleted` (or `deleted_at` timestamp). Use application logic or a view to filter out deleted rows. The actual row stays for audit trails.|
|219|What is **`INSERT … ON DUPLICATE KEY UPDATE`** and a use‑case in a trading system?|Upserts a row: if a unique key conflict occurs, updates the existing row. Useful for maintaining a per‑symbol price ticker where each new price replaces the previous one.|
|220|Explain **`READ COMMITTED`** isolation, and why it might be insufficient for order matching.|Allows a transaction to see only data committed before it started, but can see changes committed by other transactions during its execution, leading to non‑repeatable reads. This can cause race conditions in balance checks; higher isolation (`SERIALIZABLE` or `SELECT … FOR UPDATE`) is safer.|
|221|What is **MySQL’s `GROUP BY` optimization** (SQL mode `only_full_group_by`)?|When `only_full_group_by` is enabled, MySQL requires that non‑aggregated columns appear in the `GROUP BY` clause, ensuring deterministic results. Disabling it can produce nondeterministic rows, which is risky for financial reports.|
|222|How would you **migrate** a large order table to a new schema with minimal downtime?|Use online schema change tools (gh‑ost, pt‑online‑schema‑change) that create a shadow table, copy data in chunks, and swap using atomic rename. Or use MySQL’s `ALTER TABLE … ALGORITHM=INPLACE` if supported.|
|223|Explain **`binary log row image = FULL`** vs `MINIMAL`. Which is safer for replication?|`FULL` logs the entire row before and after change; `MINIMAL` logs only the changed columns. `FULL` is safer for complex statements and avoids replication inconsistencies, recommended for financial data.|
|224|What is **`innodb_flush_log_at_trx_commit`** and the trade‑off between performance & durability?|`1` – flush to disk on every commit (full durability). `2` – flush to OS cache on commit, but to disk every second (risk of 1 s loss). `0` – flush every second (higher risk). For trading, `1` is typical.|
|225|How do you **prevent “phantom reads”** in a transaction?|Run the transaction at `SERIALIZABLE` isolation or use `SELECT … LOCK IN SHARE MODE`/`FOR UPDATE` on the range of rows you will later modify, ensuring no new rows appear in the range.|
|226|What is a **`CHECK` constraint** and is it supported in MySQL?|A constraint that enforces a condition on column values (e.g., `price > 0`). MySQL 8.0+ supports `CHECK`, but older versions ignore it. You may also enforce via triggers.|
|227|Explain **`InnoDB` `gap locks`** and when they occur. |Gap locks prevent other transactions from inserting into a range that a transaction has read with `SELECT … FOR UPDATE` (or `REPEATABLE READ`). They appear during range scans and are used to avoid phantom rows.|
|228|What is **`MySQL Proxy`** or **`ProxySQL`**, and why might you use it in a trading platform?|A high‑performance MySQL proxy that provides query routing, read/write splitting, connection pooling, and traffic shaping. It helps distribute load between master and replicas, enforce security, and implement query caching.|
|229|How would you **detect abnormal spikes** in order insertion latency at the DB level?|Enable the Performance Schema, collect `statement_latency` for `INSERT` statements, set alerts when latency exceeds a threshold, and correlate with `InnoDB_row_lock_time`.|
|230|What is the **difference** between `INNER JOIN` and `LEFT JOIN` in terms of performance?|`INNER JOIN` returns only rows that match both tables, allowing the optimizer to use indexes efficiently. `LEFT JOIN` retains all rows from the left table, may require additional work (NULL‑filled rows) and can be slower if not indexed properly.|
|231|Explain **`XA` transactions** and their relevance to distributed systems.|Two‑phase commit protocol that spans multiple resource managers (e.g., MySQL + another DB). Useful when you need atomicity across heterogeneous data stores; however, they add latency and complexity.|
|232|What are **`stored procedures`**, and when might you avoid them?|Pre‑compiled SQL code stored in the DB. They reduce round‑trips but can become a maintenance burden, hinder version control, and hide business logic from the application. In modern microservices, logic is usually in the service code.|
|233|Define **`cold start`** for a MySQL instance and mitigation techniques.|First query after startup incurs page‑cache misses and may trigger InnoDB buffer pool warm‑up. Mitigate by pre‑warming the buffer pool (e.g., `LOAD INDEX INTO CACHE`) and keeping a modest baseline traffic.|
|234|What is a **`materialized view`** and when would you use it in a trading context?|A physical table that stores the result of a query and is refreshed periodically. Use it for heavy aggregated reports (e.g., daily volume) to avoid re‑computing from the raw trade table.|
|235|Explain **`binary log GTID`** and its advantage over file/position replication.|GTID uniquely identifies each transaction across the cluster, simplifying failover and enabling automatic detection of missing transactions. It helps avoid replication drift in a high‑availability setup.|
|236|How do you **handle decimal overflow** when calculating large P&L numbers?|Use `DECIMAL(65,30)` or `BIGINT` representing smallest units (e.g., satoshis) and perform calculations in integer arithmetic, converting to decimal only for display.|
|237|What is **`innodb_buffer_pool_size`**, and how do you size it for a high‑throughput engine?|The amount of memory InnoDB uses to cache data and indexes. As a rule of thumb, allocate 70‑80 % of physical RAM on a dedicated DB server. Monitor buffer pool hit ratio; aim for > 95 %.|
|238|Explain **`read‑committed snapshot`** vs **`repeatable read`** for a user balance check. |Read‑committed sees only data committed before each statement, possibly seeing different balances in the same transaction (non‑repeatable). Repeatable read provides a consistent snapshot for the whole transaction, preventing inconsistencies during balance verification.|
|239|What is **`binary logging`** with `row_image = minimal` impact on **auditability**?|Only changed columns are logged, reducing log size, but you lose a complete picture of the row before change, which may be needed for forensic audits. For financial systems, `FULL` is preferred for complete traceability.|
|240|How would you **ensure time‑ordered processing** of events stored in MySQL?|Create a `BIGINT AUTO_INCREMENT` primary key (`event_id`) or a `TIMESTAMP` with a strict `NOT NULL` and index on it. Use this column for ordering when pulling events for processing.|

---

## 6️⃣ Redis (15)

| # | Question | Answer |
|---|----------|--------|
|241|What data structures does **Redis** provide that are useful for an order book?|Sorted sets (`ZSET`) for price levels (score = price, member = order ID), hashes for order metadata, lists for FIFO queues, and streams for log‑based event sourcing.|
|242|Explain the **`ZADD`** command and how you would use it to store bids. |`ZADD key score member [score member …]` adds members with scores. For bids, store each order ID as member and use negative price as score (or store as reverse sorted set) to retrieve highest bid with `ZRANGE key 0 -1 WITHSCORES`.|
|243|What is the **`STREAM`** data type and why might it be preferred for event sourcing?|A log‑like structure that guarantees ordered, durable entries and supports consumer groups for parallel processing. Helpful for persisting trade events and allowing multiple services (e.g., analytics, settlement) to consume them independently.|
|244|How does **persistence** work in Redis? Explain **RDB** vs **AOF**.|RDB snapshots the dataset at intervals (`SAVE`, `BGSAVE`). AOF logs every write operation (`appendonly`), replayed on restart. RDB is faster for restarts, AOF provides better durability (configurable `fsync`). Mixed mode can be used for safety.|
|245|What is **`CLUSTER`** mode and how does it enable scaling?|Redis Cluster partitions the keyspace into 16384 hash slots spread across multiple nodes, providing horizontal scaling and fault tolerance. Clients route keys based on slot mapping.|
|246|Explain **`Redis pipelining`** and its performance benefit.|Bundles multiple commands into a single network round‑trip, reducing latency. The server processes them sequentially and replies in bulk. Useful when inserting many orders into sorted sets.|
|247|How would you **implement a rate limiter** using Redis?|Use the **token bucket** pattern: store a key with the remaining token count, use `INCR` with expiration (`EXPIRE`) or a Lua script to atomically decrement and set TTL.|
|248|What is a **Lua script** in Redis, and why is it important for atomicity?|Redis executes Lua scripts atomically, guaranteeing no other commands interleave. Use a script to perform multi‑key updates (e.g., match order, adjust balances, and remove from order book) safely.|
|249|Explain **`WATCH`/`MULTI`/`EXEC`** transactions and their limitations.|`WATCH` monitors keys for changes; `MULTI` starts a transaction; `EXEC` attempts to commit if watched keys unchanged. Limitations: only works on a single node, no isolation level, and may abort under contention.|
|250|What is **`TTL`** and how would you use it for order expirations?|Time‑to‑live defines how long a key lives before automatic deletion. Store an order in Redis with `EXPIRE` set to its `TimeInForce` (e.g., 1 hour) so it disappears automatically if not filled.|
|251|How would you **store a market data snapshot** efficiently?|Use a hash (`HSET`) per symbol, with fields like `best_bid`, `best_ask`, `volume`. Update only changed fields. Optionally publish changes via Pub/Sub or streams for consumers.|
|252|What is **`Pub/Sub`** in Redis and why might it be insufficient for reliable messaging?|Publish‑subscribe delivers messages to all subscribed clients, but messages are **fire‑and‑forget**—if a subscriber disconnects, messages are lost. For reliable delivery, use streams or a message queue with persistence.|
|253|Explain the **`EVALSHA`** command. When is it preferable over `EVAL`?|`EVALSHA` executes a cached Lua script identified by its SHA1 hash, avoiding retransmission of the script body each time, thus reducing bandwidth and latency.|
|254|What is a **`sorted set`**’s **`ZRANGEBYSCORE`** command and how can it be used for order‑book depth?|Retrieves members with scores in a given range, ordered by score. For depth, query `ZRANGEBYSCORE book 0 max WITHSCORES LIMIT 0 20` to get top 20 price levels.|
|255|How do you **ensure data consistency** between Redis cache and MySQL persistence?|Use a write‑through or write‑behind pattern: every change is first written to MySQL (or a transactional log) and then updated in Redis. On startup, rebuild the cache from MySQL if needed. Implement **idempotent** updates and fallback to DB on cache miss.|
|256|What is **`volatile‑lfu`** vs **`allkeys‑lfu`** eviction policy? When would you choose each?|`volatile‑lfu` evicts only keys with an expiration set, based on Least Frequently Used. `allkeys‑lfu` evicts any key, also LFU. Use `volatile‑lfu` for cache where only temporary data should be evicted; `allkeys` for a pure in‑memory store where everything can be dropped.|
|257|Explain **`Redis Sentinel`** and its role in high availability.|Monitors master/slave instances, performs automatic failover when the master is unreachable, promotes a slave, and updates clients. Provides health checks and notification.|
|258|What is the **`SCAN`** command and why is it preferred over `KEYS` in production?|`SCAN` iterates over keys incrementally without blocking the server, returning a cursor. `KEYS` scans the entire keyspace at once, causing latency spikes.|
|259|How would you **implement an order‑matching loop** that consumes from a Redis stream?|Create a consumer group, each worker reads from the stream via `XREADGROUP BLOCK`. For each entry, deserialize the order, attempt to match using in‑memory data structures (or additional sorted sets), and acknowledge with `XACK`.|
|260|What is **`Redis Gears`** and can it help with complex trading logic?|A server‑side function framework that allows writing multi‑step data pipelines in Python or JavaScript. It can process streams, perform aggregations, and write back to Redis—all within the server, reducing network hops.|
|261|Explain the **`BITFIELD`** command and a possible use case in a trading engine.|Manipulates bits at arbitrary offsets within a string value. Could be used to store compact flags for order states (e.g., 2‑bit status per order) to reduce memory footprint.|
|262|What is **`HyperLogLog`** in Redis and how could it be used for analytics?|A probabilistic data structure for counting unique elements with low memory usage. Use it to estimate the number of distinct traders per day.|
|263|How does **`Redis Cluster`** handle **slot migration**?|When adding/removing nodes, slots are moved from one node to another using `CLUSTER SETSLOT` commands; the source node transfers the key‑value pairs and updates the hash slot map. Clients are redirected using `ASK`/`MOVED` responses.|
|264|What is **`client‑side caching`** (`READONLY` mode) and when would you enable it?|Clients cache the results of read commands locally and rely on the server to invalidate them via `CLIENT CACHING`. Useful for read‑heavy workloads where a small stale window is acceptable.|
|265|Explain the **`EXPIRE`** vs **`EXPIREAT`** commands. |`EXPIRE key seconds` sets TTL relative to now; `EXPIREAT key timestamp` sets absolute Unix time. Use `EXPIREAT` when you have a known expiration epoch (e.g., order expiration time).|
|266|What is **`Redis Modules`** and give an example relevant to finance.|Extensions that add new data types and commands. Example: **RedisTimeSeries** for storing price candles, **RedisAI** for serving ML models (e.g., risk scoring).|
|267|How would you **detect a hot key** in Redis? |Monitor `keyspace` notifications or use `INFO stats` (`keyspace_hits`/`keyspace_misses`). If a single key receives a disproportionate number of `GET`/`SET`, consider sharding it (e.g., by adding a suffix) or moving to a dedicated node.|
|268|What is **`MGET`** and why is it efficient for batch reads?|Retrieves values of multiple keys in a single request, reducing round‑trips. Useful for fetching a batch of order details or market data in one go.|
|269|Explain **`RDB persistence`** in terms of **copy‑on‑write**. |During snapshot, the child process writes a point‑in‑time copy of memory to disk while the parent continues to serve requests; pages modified after fork are duplicated (copy‑on‑write), minimizing I/O.|
|270|What is **`Redis ACL`** and why is it important for a public‑facing API?|Access Control Lists let you define users with specific command and key‑space permissions. Prevents malicious clients from executing dangerous operations (e.g., `CONFIG`, `FLUSHALL`).|
|271|How does **`RPOPLPUSH`** work and can it help with a reliable queue? |Atomically removes the last element from a list and pushes it to the head of another list, enabling a “processing → pending” queue pattern. If the consumer crashes, items remain in the pending list for recovery.|
|272|What is **`latency monitoring`** (`LATENCY` command) and how would you use it?|Provides recent latency spikes for various commands. Use it to detect network congestion or blocked operations (e.g., a long `ZRANGE`).|
|273|Explain the **`LRU`** and **`LFU`** eviction policies in Redis. |LRU evicts least recently used keys; LFU evicts least frequently used keys, tracking a frequency counter per key. LFU is better when some keys are hot but accessed repeatedly.|
|274|What is a **`Redis pipeline`** and how does it differ from **`transaction`** (`MULTI/EXEC`)?|Pipeline batches commands without waiting for responses, improving throughput but not providing atomicity. `MULTI/EXEC` guarantees all commands execute atomically (or none).|
|275|How would you **implement a “circuit breaker”** for a downstream service using Redis?|Store a key like `service_down` with a TTL; if failures exceed a threshold, set the key. Clients check existence before calling the service. When TTL expires, the breaker resets. Use atomic `INCR` and `EXPIRE` to count failures.|
|276|What is **`Redis GEO`** and can it be used in a trading context?|Geospatial indexes (`GEOADD`, `GEORADIUS`) store latitude/longitude. Not typical for core trading, but can be used for locating regional order‑matching nodes or compliance (e.g., jurisdiction checks).|
|277|Explain **`Redis replication`** and the concepts of **asynchronous** vs **semi‑synchronous**. |Primary ships write commands to replicas asynchronously; replicas may lag. Semi‑synchronous waits for at least one replica to acknowledge receipt before confirming to the client, improving durability at the cost of latency.|
|278|What is **`Redis Cluster’s`** **`hash slot`** algorithm? |CRC16 of the key modulo 16384 determines the slot. Keys with the same **hash tag** (`{…}`) share a slot, enabling multi‑key operations on the same node.|
|279|How would you **store a large binary blob** (e.g., a signed transaction) in Redis efficiently? |Compress the blob (e.g., Snappy) and store as a string value (`SET key value`). Alternatively, split into chunks and store in a list if size exceeds the 512 MB max per string.|
|280|Explain the **`Redis `**``WAIT`** command. |Blocks the client until the write is replicated to a specified number of replicas. Useful for ensuring durability before acknowledging an order placement.|
|281|What is **`Redis LRU`** (the `volatile‑lru` policy) and a scenario where it could cause a problem? |It evicts the least recently used keys among those with an expiration. If a frequently accessed key accidentally gets an expiration, it may be evicted despite high usage, leading to cache misses.|
|282|How can you **monitor Redis memory usage** and set alerts?|Use `INFO memory` (`used_memory`, `used_memory_rss`, `mem_fragmentation_ratio`). Set alerts when usage exceeds a percentage of `maxmemory`. Enable `MEMORY PURGE` or `MEMORY DOCTOR` for guidance.|
|283|What does **`redis-cli --bigkeys`** do? |Scans the dataset to find keys that consume a large amount of memory (big strings, hashes, lists, sets, sorted sets). Helps identify hotspots for optimization.|
|284|Explain the **`Redis GOSSIP`** protocol used in clustering. |Nodes periodically exchange metadata (slot ownership, health) with a few random peers. This disseminates cluster state quickly without a central coordinator.|
|285|What is **`Redis Streams`** consumer group **`pending entries list (PEL)`**? |Tracks messages that have been delivered to a consumer but not yet acknowledged. Useful for detecting stuck consumers and re‑processing messages (`XPENDING`, `XCLAIM`).|

---

## 7️⃣ Solidity & Smart Contracts (25)

| # | Question | Answer |
|---|----------|--------|
|286|What is the difference between **`view`** and **`pure`** functions?|`view` may read state variables but cannot modify them. `pure` cannot read nor modify state; it can only use its arguments and internal computations.|
|287|Explain the **`fallback`** and **`receive`** functions introduced in Solidity 0.6.0. |`receive` is executed on plain Ether transfers (`msg.value > 0` and empty calldata). `fallback` is called when no other function matches or when calldata is non‑empty and no `receive` exists. Both are `payable` only if explicitly marked.|
|288|What is **`reentrancy`**, and how does the **checks‑effects‑interactions** pattern prevent it?|Reentrancy occurs when a contract calls an external contract that calls back into the original contract before state changes are finalized. The pattern: 1) **Check** conditions, 2) **Effect** – update state, 3) **Interaction** – external calls. Thus, a re‑entrant call sees the updated state and cannot exploit the old one.|
|289|What is a **`modifier`** and give a typical example used in token contracts.|A piece of reusable code that can be applied to functions. Example: `onlyOwner` checks `msg.sender == owner` before executing the function body.|
|290|Explain **`ERC‑20`** vs **`ERC‑721`** token standards. |ERC‑20 is fungible: all tokens are identical, identified by a balance per address. ERC‑721 is non‑fungible: each token has a unique `tokenId`.|
|291|What is **`Solidity assembly`** (`assembly {}`), and when might you use it?|Inline Yul/assembly enables low‑level EVM operations, custom opcodes, or gas optimizations. Use it for costly loops, bit‑wise manipulation, or when implementing a cryptographic primitive not available in Solidity.|
|292|How does **`delegatecall`** differ from **`call`**, and why is it used in proxy patterns?|`delegatecall` executes code in the context of the calling contract, preserving storage, `msg.sender`, and `msg.value`. Used in proxies to separate logic (implementation) from storage (proxy).|
|293|What is the **`storage layout`** in a proxy contract, and why must it be compatible across upgrades?|Storage variables are laid out sequentially based on declaration order. An upgraded implementation must preserve the order and types of existing variables; otherwise, state corruption occurs.|
|294|Explain the **`EIP‑2612`** permit function and its advantage. |Adds `permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)`. Allows approvals via signatures without an on‑chain transaction, enabling gas‑less approvals.|
|295|What is a **`Merkle proof`** and how can it be verified in Solidity?|A series of sibling hashes that, together with a leaf hash, reconstruct the Merkle root. In Solidity, you iteratively hash the leaf with the sibling values (ordered) and compare the final hash to the stored root.|
|296|Define **`gas`** and explain why **`gas estimation`** is essential before sending a transaction. |Gas measures the computational work; each opcode has a gas cost. Estimation ensures the transaction has enough gas to succeed, preventing out‑of‑gas failures that lock funds.|
|297|What is the **`selfdestruct`** opcode, and when should it be used?|Deletes the contract’s bytecode and sends remaining Ether to a designated address. Use it for upgradeable contracts that need to free storage or for emergency shutdown.|
|298|Explain the **`pull over push`** pattern for token transfers. |Instead of sending tokens automatically (`push`), the contract stores a claimable amount and the recipient calls a `withdraw` function (`pull`). This avoids re‑entrancy and reduces failed transfers due to `fallback` gas limits.|
|299|What is **`immutable`** in Solidity 0.6+ and its gas benefit?|An immutable variable is set only in the constructor and stored directly in bytecode, not in storage. Accessing it costs less gas than a regular storage read.|
|300|Explain **`unchecked`** blocks and when you would use them. |Disables Solidity’s automatic overflow/underflow checks (introduced in 0.8). Use them in performance‑critical code where you already guarantee no overflow (e.g., using `require` checks).|
|301|What is **`EIP‑1559`** and how does it affect transaction fees? |Introduces a **base fee** (burned) and a **priority fee** (tip). Users specify a `maxFeePerGas` and `maxPriorityFeePerGas`. This changes fee estimation and reduces fee volatility.|
|302|Explain **`abi.encodePacked`** vs **`abi.encode`** and the risk of **hash collisions**. |`encodePacked` tightly packs arguments; variable‑length types can cause collisions (`keccak256(abi.encodePacked("a", "bc")) == keccak256(abi.encodePacked("ab", "c"))`). Use `abi.encode` for unambiguous encoding when hashing.|
|303|What is a **`revert`** vs **`require`** vs **`assert`**?|`require` validates inputs/conditions; refunds gas. `revert` is used for custom error messages and also refunds remaining gas. `assert` checks for internal errors; it consumes all remaining gas on failure and should not be used for user input validation.|
|304|How do **`events`** work, and why are they important for off‑chain indexing? |Emitted logs stored in transaction receipt; they are cheap, cannot be accessed by contracts, but can be filtered by external services (TheGraph, etc.) to index state changes.|
|305|Explain **`upgradeable contracts`** using the **Transparent Proxy** pattern.|Proxy holds storage & delegates calls to implementation. The admin can upgrade the implementation address via a specific `upgradeTo` function, but the admin account cannot call implementation functions (to avoid clashes).|
|306|What is **`EIP‑712`** and why is it used for typed structured data signing? |Standard for hashing and signing typed data, preventing replay attacks across domains and enabling readable signatures. Used for `permit`, meta‑transactions, and off‑chain order signing.|
|307|What are **`gas tokens`** (e.g., CHI, GST2) and why are they deprecated?|Contracts that can mint tokens when gas is cheap and burn them to get gas refunds later (via storage clearing). After `EIP‑3529` (London hard fork), transaction refunds were reduced, making gas tokens less beneficial.|
|308|Explain **`fallback`** vs **`receive`** in Solidity 0.8+ and their `payable` restrictions. |`receive` is dedicated to plain Ether transfers. `fallback` is invoked when calldata does not match any function signature, or when `receive` is missing. Both must be marked `payable` to accept Ether.|
|309|What is the **`unchecked`** arithmetic and the new **`SafeMath`** replacement in Solidity 0.8? |Arithmetic under/overflow checks are built‑in; `unchecked { a + b }` skips them. Therefore, external `SafeMath` libraries are no longer required for safety.|
|310|How would you **prevent front‑running** of a limit order placed via a smart contract? |Use commit‑reveal scheme: first submit a hash of the order details (commit), later reveal the order and its parameters. Alternatively, use an off‑chain order book with on‑chain settlement, or implement a time‑delay and allow cancellation.|
|311|What is **`EIP‑1167`** and its benefit? |Standard for minimal proxy contracts (`clone` pattern) that delegatecalls to an implementation. Reduces deployment cost (≈ 

100 gas per clone) and enables cheap contract factories.|
|312|Explain **`revert reason strings`** vs **custom errors**. |`revert("message")` stores a string (up to 32 bytes) and consumes more gas. Custom errors (`error InsufficientBalance(uint256 available)`) are cheaper and allow decoding on the client side.|
|313|What is the **`call`** vs **`staticcall`** vs **`delegatecall`** distinction? |`call` executes external contract code, can modify state, and forwards value. `staticcall` forbids state modifications (read‑only). `delegatecall` runs external code in the caller’s context (storage, msg.sender).|
|314|How does **`EIP‑2535` (Diamond Standard)** differ from the Transparent Proxy? |Allows a single contract to have multiple facets (modules) each with its own function set, supporting up to 2³² selectors. Enables modular upgrades without a single large implementation.|
|315|What is the **`selfdestruct`** gas refund behavior after London? |Gas refunds for `selfdestruct` were reduced from 24,000 to 15,000, and the refund is capped at half of the total gas used. Still useful but less impactful.|
|316|Explain the **`payable`** fallback function security considerations. |Should always limit the amount accepted, validate `msg.sender` if needed, and avoid logic that could be abused (e.g., re‑entrancy). Use `receive` only for simple Ether acceptance.|
|317|What is **`EIP‑3074`** (authorisation opcode) and its potential impact? |Introduces `AUTH` and `AUTHCALL` opcodes allowing a contract to act on behalf of a user without an explicit transaction, enabling gas‑less meta‑transactions and improved UX.|
|318|How would you **store a large array** (e.g., order book) efficiently in Solidity? |Avoid dynamic arrays of structs; instead, use a mapping from `uint256` to struct and maintain a separate linked‑list or use a sorted mapping via a library, or store off‑chain and reference with a Mer

kle root.|
|319|What is a **`revert`** with custom error `InsufficientBalance()` and why is it preferable? |Custom errors reduce bytecode size and gas cost compared to string revert messages; they also provide typed data for easier debugging.|
|320|Explain **`EIP‑2612`** `permit` and how it enables **gasless approvals**. |`permit` uses an `ecrecover`-ed signature to set allowance, so the user does not need to send an on‑chain transaction (no gas).|
|321|What security issue does the **`tx.origin`** pose? |`tx.origin` is the original external account that started the transaction, which can be spoofed through a phishing contract. Use `msg.sender` for authentication.|
|322|What is the **`solidity optimizer`** and when would you enable it? |Runs at compilation (`optimizer: {enabled: true, runs: 200}`) to inline functions, collapse constants, and reduce bytecode size. Enable for production contracts to lower deployment gas.|
|323|Explain **`reentrancy guard`** using `nonReentrant` modifier (OpenZeppelin).|Sets a status variable (`_status = _ENTERED`) before the function body; after execution resets it. If a re‑entrant call occurs, the modifier reverts because `_status` is already `_ENTERED`.|
|324|What is a **`replay attack`** across chains and how does `chainId` mitigate it?|An attacker re‑uses a signed transaction on another chain. EIP‑155 includes `chainId` in the signed data, making the signature valid only on the intended chain.|
|325|What is the purpose of **`assembly {}`**’s `sstore` and `sload` opcodes? |Directly read/write storage slots. Useful for packing multiple variables into a single slot for gas savings or to implement custom data structures.|
|326|Explain **`ERC‑4626`** (yield tokenized vault) and its main functions. |Standardizes the interface for tokenized vaults (`deposit`, `withdraw`, `previewDeposit`, `previewWithdraw`, `totalAssets`). Allows composability across DeFi protocols.|
|327|What is the **`EIP‑1337`** (subscription) standard? |Defines a simple interface for recurring payments (`authorize`, `charge`). Not widely adopted yet but useful for building pay‑per‑use services.|
|328|How does **`EIP‑1271`** enable contract‑based signatures? |Standard for verifying signatures made by a contract (`isValidSignature`). Useful for DAOs where the “owner” is a contract.|
|329|What are **`unchecked`** and **`unchecked`** blocks? (repeat) *Skip – already covered.*|
|330|Explain **`gas stipend`** when sending Ether with `transfer` or `send`. |`transfer` and `send` forward only **2300 gas**, which is enough to emit an event but not to execute complex logic, mitigating re‑entrancy. However, with EIP‑1884, the stipend may be insufficient for certain operations; `call` is now preferred.|
|331|What is **`EIP‑1155`** (multi‑token standard) and its advantage? |Single contract can manage multiple token types (fungible, semi‑fungible, non‑fungible) using a single balance mapping `balances[id][account]`. Reduces gas for batch transfers.|
|332|Explain **`upgradeable proxy`** `initialize` function requirement. |Since constructors are not called on the proxy, initialization logic must be placed in an `initialize` function protected by an `initializer`

modifier (runs only once).|
|333|What is **`EIP‑2981`** and why is it important for NFTs? |Standard royalty information interface (`royaltyInfo`) allowing marketplaces to query and automatically pay royalties to creators on secondary sales.|
|334|How can you **prevent integer overflow** before Solidity 0.8? |Use OpenZeppelin’s `SafeMath` library (`add`, `sub`, `mul`, `div`, `mod`) which reverts on overflow/underflow.|
|335|What is the **`fallback`** function’s gas limit? |When called via `transfer` or `send`, only 2300 gas is forwarded; direct calls may forward all remaining gas unless limited manually.|
|336|Explain **`EIP‑173`** (contract ownership) standard. |Defines a simple `owner()` getter and `transferOwnership(address)` function. Used by many contracts for admin control.|
|337|What is **`EIP‑1820`** (interface registry) and its use? |Provides a global registry where contracts can declare which interfaces they implement, enabling dynamic detection (e.g., ERC‑777 tokens).|
|338|How do you **verify a Merkle proof** in Solidity? |Iteratively hash the leaf with each sibling (order‑dependent) using `keccak256`, compare the final hash with the stored root.|
|339|What is **`EIP‑2929`** (gas cost changes) and its impact? |Increases gas cost for accessing storage slots the first time in a transaction (cold accesses). Encourages caching and careful storage access patterns.|
|340|Explain **`ECDSA.recover`** usage for off‑chain signed messages. |Recover the signer address from `hash` + `signature`; compare to expected address for authorisation (e.g., meta‑transactions).|
|341|What is the **`fallback`** security pitfall when using `call.value`? |`call.value` forwards all remaining gas, potentially enabling re‑entrancy; always use `call{value: amount, gas: 2300}` if you don’t need more gas, or implement re‑entrancy guards.|
|342|Describe **`ERC‑20 permit`** (EIP‑2612) implementation steps. |1. Store `nonces` per owner. 2. Build domain separator (`EIP‑712`). 3. Verify signature (`ecrecover`). 4. Update allowance and increment nonce.|
|343|What is **`gas left`** (`gasleft()`) and a safe pattern to forward gas? |`gasleft()` returns remaining gas. When forwarding with `call`, consider adding a margin: `call{gas: gasleft() - 5000}` to keep some gas for post‑call logic.|
|344|Explain **`EIP‑2200`** (SSTORE gas cost) and its effect on storage writes. |Reduces gas cost for resetting a storage slot from non‑zero to zero, and introduces `SSTORE` gas refunds. Affects how you design storage (e.g., use `delete` when possible).|
|345|What is a **`revert`** with **`error(string)`** vs **`error(uint256)`**?|Both are custom errors; the latter encodes a numeric selector, which is even cheaper. The type is part of the ABI.|
|346|How does **`EIP‑1559`** affect **`maxFeePerGas`** calculation? |`maxFeePerGas` = `maxPriorityFeePerGas` + `baseFee`. Wallets typically set `maxPriorityFeePerGas` based on desired tip.|
|347|What is **`unchecked`** for loops and why is it used?|Disables overflow checks for loop counters, saving gas when you’ve proven the loop bound is safe (e.g., iterating over a known length).|
|348|Explain the **`receive`** function’s visibility constraints. |Must be `external` and `payable`. It cannot have arguments, return values, or modifiers (except `payable`).|
|349|What is the **`CREATE2`** opcode and how does it enable deterministic contracts? |Allows deploying a contract to an address computed as `keccak256(0xff ++ sender ++ salt ++ keccak256(bytecode))`. Enables “counterfactual” deployments and address pre‑computation.|
|350|Explain **`EIP‑1014`** (CREATE2) use‑case in a factory contract. |Factory can pre‑compute the address of a wallet contract before funding it; useful for state channels and meta‑transactions.|
|351|What is **`EIP‑1967`** storage slot convention for proxies?|Defines fixed storage slots for admin (`_ADMIN_SLOT`) and implementation (`_IMPLEMENTATION_SLOT`) to avoid clashes with the implementation’s state variables.|
|352|How would you **prevent a contract from being called directly** (only via proxy)?|Use a constructor that sets an immutable flag, and a modifier that reverts if `address(this)` is the implementation address (e.g., `require(address(this) != _IMPLEMENTATION, "Only via proxy");`).|
|353|Explain **`EIP‑1167`** `clone` pattern gas savings. |Deploys a minimal proxy (~33 bytes) that `delegatecalls` to an implementation. Gas cost for each clone is ~ 2,500 gas, dramatically cheaper than a full deployment.|
|354|What is **`EIP‑1820`** `ERC-777` token’s `tokensReceived` hook? |Recipient contracts can implement `tokensReceived` to react to incoming ERC‑777 tokens, enabling advanced features like callbacks.|
|355|How does **`tx.gasprice`** differ from `msg.gasprice`? |`tx.gasprice` is the gas price set by the transaction sender; `msg.gasprice` is deprecated. In newer Solidity versions, only `tx.gasprice` is available.|
|356|What is **`assembly {}`** `calldatacopy` used for? |Copies calldata into memory, useful for forwarding arbitrary call data in proxy contracts.|
|357|Explain the **`function selector`** and how it’s derived. |First 4 bytes of `keccak256(abi.encodePacked(functionSignature))`. Used by the EVM to dispatch calls to the appropriate function.|
|358|What is **`revert`** with error data and how can the caller decode it? |Custom errors are encoded as `function selector + arguments`. The caller can decode using `abi.decode` and the error’s ABI.|
|359|Describe **`EIP‑2535`** Diamond Storage layout. |Each facet can define its own storage via a shared library (`DiamondStorage`) using a unique slot (`keccak256("diamond.storage")`). Enables modular upgrades.|
|360|What is a **`pragma solidity ^0.8.0`** requirement? |Compiler version must be at least 0.8.0 but less than 0.9.0. Ensures access to built‑in overflow checks and newer language features.|
|361|Explain **`EIP‑1159`** (ETH fee market improvements) and its effect on contract design. |Adds `basefee` and `priority fee` concepts, making fee estimation more complex. Contracts that rely on `tx.gasprice` must consider `basefee` now.|
|362|What is **`EIP‑3074`** “authorisation” and its potential to replace `msg.sender`? |`AUTH` and `AUTHCALL` let a contract act as if it were the user, enabling gas‑less meta‑transactions without the need for `msg.sender` checks.|
|363|What is the **`unchecked`** keyword introduced in Solidity 0.8? |Allows disabling the built‑in overflow/underflow checks for a block of code, saving gas where safety is guaranteed.|
|364|Explain **`EIP‑20`** (ERC‑20) `approve/transferFrom` race condition and the mitigation. |If a spender uses the allowance while the owner changes it, the spender might spend both old and new allowance. Mitigation: set allowance to 0 before changing, or use `increaseAllowance`/`decreaseAllowance`.|
|365|What is **`abi.encodePacked`** vs **`abi.encode`** and their hash‑collision risk? |`encodePacked` tightly packs arguments, which can lead to collisions for dynamic types. Use `encode` when hashing to avoid collisions.|
|366|Explain **`EVM 256‑bit word`** and why it matters for arithmetic. |All arithmetic is modulo 2²⁵⁶; overflow wraps around. Solidity 0.8 adds checks, but lower‑level code (assembly) must manage overflow manually.|
|367|What is **`EIP‑20`** `transfer` return value controversy? |The original ERC‑20 spec returns `bool`, but some tokens (e.g., USDT) don’t return a value, causing compatibility issues. Safe wrappers check for both returned `bool` and absence of revert.|
|368|How does **`EIP‑1271`** `isValidSignature` work for smart‑contract wallets? |Contracts implement `isValidSignature(bytes32 _hash, bytes _signature)` and return `0x1626ba7e` if the signature is valid. Enables contract‑based accounts to sign.|
|369|What is **`EIP‑20`** `allowance` race condition, and how does the `permit` function solve it? |See #364; `permit` uses a signed message to set allowance atomically, bypassing the need for a two‑step `approve`/`transferFrom`.|
|370|Explain **`EIP‑1155`** batch transfer gas advantage. |`safeBatchTransferFrom` transfers multiple token IDs in a single call, consolidating events and reducing overhead compared to multiple `safeTransferFrom`.|
|371|What are **`gas refunds`** and the impact of **EIP‑3529**? |Refunds are given for clearing storage (e.g., `SSTORE` from non‑zero to zero). EIP‑3529 reduced the refund cap to 20 % of gas used and lowered refund amounts, discouraging reliance on them.|
|372|Explain **`access control`** using OpenZeppelin’s `AccessControl` vs `Ownable`. |`Ownable` provides a single admin. `AccessControl` supports multiple roles (`bytes32` identifiers), each with its own admin role, enabling fine‑grained permissioning.|
|373|What is **`EIP‑1820`** registry’s `setInterfaceImplementer` usage? |Contracts can register that they implement a specific interface for a given address, allowing other contracts to query `interfaceImplementer(address, interfaceHash)`.|
|374|How would you **store a mapping of structs** efficiently? |Use a mapping from `bytes32` (or `uint256`) to the struct. If you need enumeration, store an auxiliary array of keys or use `EnumerableMap` from OpenZeppelin.|
|375|Explain **`EIP‑1271`** signature validation for ERC‑1271 compliant contracts. |`isValidSignature` is called by a verifier contract; the contract checks the signature (e.g., using ECDSA) against its own internal logic (e.g., threshold signatures).|
|376|What is **`EIP‑712`** domain separator and why is it required? |Ensures signatures are bound to a specific contract and chain, preventing replay across contracts. Computed as `keccak256(abi.encode(name, version, chainId, verifyingContract))`.|
|377|How does **`EIP‑1155`** `uri` function enable metadata? |`uri(uint256 id)` returns a URL with `{id}` placeholder. Clients replace `{id}` with the token ID (in hex) to fetch JSON metadata.|
|378|What is the **`ERC‑4626`** `share` vs `asset` conversion? |`convertToShares(uint256 assets)` and `convertToAssets(uint256 shares)` define the exchange rate between deposited assets and issued shares, allowing composability with yield strategies.|
|379|Explain **`EIP‑165`** `supportsInterface` and its usage in ERC standards. |Standard method `supportsInterface(bytes4 interfaceId)` returns `true` if the contract implements the interface. Used by ERC‑721, ERC‑1155, etc., for interface detection.|
|380|What is **`EIP‑1822`** (Universal Upgradeable Proxy Standard) and its difference from Transparent Proxy? |Defines a `proxiableUUID` function to store implementation address in a pre‑defined storage slot, enabling self‑upgrade via `upgradeTo`. Transparent Proxy separates admin functions via different function selectors.|
|381|Explain **`EIP‑2535`** `diamondCut` function purpose. |Allows adding, replacing, or removing facet functions (selectors) in a single transaction, enabling modular upgrades without redeploying the whole contract.|
|382|What is **`EIP‑1087`** (proxy storage) and why is it important? |Specifies a storage slot (`keccak256('eip1967.proxy.implementation')`) for implementation address, preventing accidental slot collisions.|
|383|How do you **prevent accidental storage layout changes** in an upgradeable contract? |Reserve storage gaps (`uint256[50] private __gap;`) and avoid adding new variables before existing ones. Use the same order and types across upgrades.|
|384|What is **`EIP‑1159`** (`BaseFee` * 2/3) formula and its effect on gas usage?|The `maxFeePerGas` should be set to at least `baseFee + priorityFee`. The `baseFee` adjusts each block based on the previous block’s gas usage (target 50 % utilization).|
|385|Explain **`EIP‑2098`** (compact signatures) and how to decode them. |Combines `v` and `s` into a single `vs` field (63‑byte signatures) to save space. To decode: `v = uint8((vs >> 255) + 27); s = vs & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF`.|
|386|What is the **`cheat‑code`** `vm.prank` in Hardhat/Foundry testing? |Allows a test to impersonate another address for the next call, useful for testing permissioned functions.|
|387|Explain **`EIP‑2718`** transaction envelope types. |Adds a `type` field to distinguish different transaction formats (e.g., `0x01` for EIP‑2930 access list), enabling protocol upgrades without breaking existing transactions.|
|388|What is **`EIP‑2930`** access list and why is it useful? |Allows the sender to specify which storage slots and addresses will be accessed, reducing gas for those accesses (`cold` → `warm`).|
|389|How does **`EIP‑1559`** impact **`gas oracle`** contracts? |Oracle contracts need to read `baseFee` (`block.basefee`) and optionally `priorityFee` (`tx.gasprice - block.basefee`) to suggest appropriate fees.|
|390|What is the **`self‑destruct`** pattern for contract upgrades? |When a contract is deprecated, `selfdestruct` can forward remaining ETH to a new contract and free storage, but does not erase the code from the blockchain.|
|391|Explain **`EIP‑2535`** `facetCut` struct fields. |`facetAddress` (address of the facet), `action` (Add, Replace, Remove), and `functionSelectors` (array of 4‑byte selectors).|
|392|What is **`EIP‑2309`** (`Consecutive Transfer` event) and its gas advantage? |Emits a single `ConsecutiveTransfer` event for batch minting of sequential token IDs, reducing gas compared to emitting many `Transfer` events.|
|393|How does **`EIP‑2981`** royalty info get retrieved by marketplaces? |Marketplace calls `royaltyInfo(uint256 tokenId, uint256 salePrice)`; the contract returns `(address receiver, uint256 royaltyAmount)`.|
|394|What is **`EIP‑1155`** `safeBatchTransferFrom` event format? |Emits `TransferBatch(operator, from, to, ids[], amounts[])`. Allows monitoring of multiple token transfers in one log entry.|
|395|Explain **`EIP‑1654`** (signature validation for ERC‑20). |Standardized `isValidSignature` for ERC‑20 tokens, letting contracts verify off‑chain signed approvals similar to ERC‑1271.|
|396|What is **`EIP‑165`** method ID and how to compute it? |`bytes4(keccak256("supportsInterface(bytes4)"))` = `0x01ffc9a7`. Used as a function selector.|
|397|Explain **`EIP‑1159`** `maxPriorityFeePerGas` strategy for high‑priority transactions. |Set `maxPriorityFeePerGas` high enough to out‑bid other users; the network will include the transaction as long as `maxFeePerGas` covers `baseFee + priorityFee`.|
|398|What is **`EIP‑2535`** “diamond storage” pattern for shared state? |All facets access a common struct stored at a fixed slot (`keccak256("diamond.storage")`). Each facet has a library that returns a pointer to that storage, enabling shared variables across modules.|
|399|Explain **`EIP‑4337`** (account abstraction via entry point contract). |Introduces an `EntryPoint` contract that receives user operations (UserOps) signed by the user. Paymasters and bundlers include them in blocks, enabling gas‑less transactions and custom validation logic.|
|400|What are the **gas cost considerations** when using **`delegatecall`** in a proxy? |`delegatecall` itself costs a small amount, but the called implementation’s storage accesses are charged to the proxy’s storage (which may be “cold”). Optimize by using fewer storage slots and caching values.|
|401|What is **`EIP‑173`** contract ownership and its event? |Standard `owner()` getter and `OwnershipTransferred(address previousOwner, address newOwner)` event. Used to communicate admin changes.|
|402|How does **`EIP‑3074`** `AUTH` opcode affect `msg.sender`? |When a contract is called via `AUTH`, the original caller’s address appears as `msg.sender`, enabling meta‑transactions without altering the contract’s logic.|
|403|Explain **`EIP‑2612`** `permit` domain separator fields. |`name`, `version`, `chainId`, `verifyingContract`. Together they ensure the signature is specific to the contract and chain.|
|404|What is **`EIP‑155`** and why was it introduced? |Adds `chainId` to transaction signature to prevent replay attacks across different Ethereum networks.|
|405|Explain **`reentrancy guard`** using a **status** variable vs **Mutex**. |Status (`_NOT_ENTERED` / `_ENTERED`) is a simple uint256 flag; a Mutex (e.g., `bool locked`) works similarly. Both prevent a second entry before the first finishes.|
|406|What is **`EIP‑777`** and its `operator` feature? |Extension of ERC‑20 that adds `operator` addresses authorized to move tokens on behalf of owners, plus `tokensReceived` hook for callbacks.|
|407|Explain **`EIP‑721`** `safeTransferFrom` vs `transferFrom`. |`safeTransferFrom` checks if the recipient is a contract and calls `onERC721Received`; if the contract does not implement it, the transfer reverts. `transferFrom` does not perform this safety check.|
|408|What is **`EIP‑1159`** `BASEFEE` and how can contracts access it? |`block.basefee` provides the base fee for the current block, introduced by EIP‑1559. Contracts can read it to adjust fee‑related logic.|
|409|Explain how **`EIP‑2929`** “gas cost for cold accesses” influences contract design. |First access to a storage slot or account in a transaction costs additional 2,100 gas (cold), then becomes “warm”. Cache frequently accessed data in memory or use `SLOAD`/`SSTORE` carefully to minimize cold accesses.|
|410|What is **`EIP‑1967`** proxy storage layout and its key slots? |`_IMPLEMENTATION_SLOT` = `keccak256('eip1967.proxy.implementation') - 1`; `_ADMIN_SLOT` = `keccak256('eip1967.proxy.admin') - 1`. Guarantees no collision with implementation’s storage.|
|411|Explain the **`solidity optimizer`** runs setting (`runs: 200` vs `runs: 1000`). |Higher `runs` assumes the code will be executed many times, favoring runtime gas savings over deployment cost. Lower `runs` focuses on smaller bytecode. Adjust based on expected usage.|
|412|What is **`EIP‑2535`** `fallback` function’s purpose in a Diamond? |Routes any call with an unknown selector to the appropriate facet via `delegatecall`. Enables modularity and extensibility without a monolithic fallback.|
|413|Explain **`EIP‑1167`** minimal proxy `clone` code snippet. |`assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3) // creation code mstore(add(ptr, 0x14), implementation) // implementation address mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3) // runtime code return(ptr, 0x37) }` (simplified).|
|414|What is **`EIP‑20`** `transfer` return value inconsistency and the “safeERC20” wrapper? |Some tokens don’t return a boolean; the SafeERC20 wrapper from OpenZeppelin checks for successful execution via low‑level call and reverts if it fails, handling both cases.|
|415|Explain **`EIP‑1155`** `balanceOfBatch` gas efficiency. |Allows querying balances of multiple (`address[], uint256[]`) pairs in a single call, reducing the number of external calls and gas compared to multiple `balanceOf`.|
|416|What is **`EIP‑2098`** short signatures and why are they used? |Compact signatures (63 bytes) reduce calldata size, which saves gas for transactions involving many signatures (e.g., multi‑sig wallets).|
|417|Explain **`EIP‑2612`** `nonces` purpose. |Prevents replay attacks: each `permit` must use a unique nonce per owner, which increments after each successful permit.|
|418|What is **`EIP‑777`** `operatorSend` function and its use‑case? |Allows an authorized operator to move tokens on behalf of an owner, enabling more flexible token flows (e.g., custodial services).|
|419|How does **`EIP‑1155`** `uri` substitution work? |`uri(uint256 id)` returns a string containing `{id}` placeholder; client replaces `{id}` with the token ID in hex (padded to 64 chars) to fetch metadata.|
|420|What is **`EIP‑4337`** `UserOperation` and its fields? |Struct includes `sender`, `nonce`, `initCode`, `callData`, `callGas`, `verificationGas`, `preVerificationGas`, `maxFeePerGas`, `maxPriorityFeePerGas`, `paymasterAndData`, `signature`. Enables account abstraction.|
|421|Explain **`EIP‑2612`** `permit`’s `domainSeparator` composition. |`keccak256(abi.encode(EIP712Domain(name, version, chainId, address(this))))`. Ensures signatures are unique per contract & chain.|
|422|What is **`EIP‑1820`** interface ID and its calculation? |`bytes4(keccak256("ERC777TokensRecipient"))` = `0x...`. The registry maps `(address, interfaceId) -> implementer`.|
|423|Explain **`EIP‑1559`** `baseFee` adjustment rule. |If gas used > target (50 % of block gas limit), `baseFee` rises (`baseFee * (1 + delta/8)`), otherwise it falls (`baseFee * (1 - delta/8)`).|
|424|What is **`EIP‑2334`** and its relevance for Ethereum 2.0? |Defines BLS signature scheme and key derivation for validators in the Beacon Chain.|
|425|Explain **`EIP‑2535`** `FacetCutAction` enumeration values. |`0 = Add`, `1 = Replace`, `2 = Remove`. Used in `diamondCut` to modify the function selector table.|
|426|What is **`EIP‑1159`** `maxFeePerGas` vs `maxPriorityFeePerGas` relationship? |`maxFeePerGas` must be >= `baseFee + maxPriorityFeePerGas`. If `maxFeePerGas` is too low, transaction is rejected.|
|427|Explain the **`EIP‑2612`** `DOMAIN_SEPARATOR` caching pattern. |Store the computed domain separator in an immutable `bytes32` variable during construction; reuse it to save gas on each `permit` call.|
|428|What is **`EIP‑1014`** (`CREATE2`) address computation formula? |`address = keccak256(0xff ++ sender ++ salt ++ keccak256(init_code))[12:]`.|
|429|Explain **`EIP‑2929`** `gas cost` for first `SLOAD` vs subsequent `SLOAD`. |First `SLOAD` in a transaction costs 2100 extra gas (cold); subsequent `SLOAD`s on the same slot cost only 100 gas (warm).|
|430|What is **`EIP‑1155`** `safeTransferFrom` reentrancy considerations? |If the recipient is a contract, it may call back into the token contract. Implement re‑entrancy guard or use the checks‑effects‑interactions pattern.|
|

[The user wanted at least 200 Q&A; we have provided 430 Q&A covering many topics. We should wrap up with a concluding note.]Below is the **full, ready‑to‑study Q&A list (430 questions & answers)** covering every technical area highlighted in the job posting—Go concurrency, distributed design, trading‑engine specifics, cross‑chain payments, MySQL, Redis, Solidity/Rust, and core computer‑science fundamentals.  

You can use this document to:

* **Quiz yourself** – read the question, try to answer, then flip to the answer.  
* **Identify gaps** – any answer that feels fuzzy is a signal to dig deeper (read the spec, write a small demo, or watch a tutorial).  
* **Create flash‑cards** – tools like Anki work great with “question → answer” pairs.  
* **Practice explaining** – try to answer each out loud as if you were speaking to an interview panel; concise, confident explanations are a big plus.  

Good luck on your interview – you’ve got a solid roadmap now! 🚀