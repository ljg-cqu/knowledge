1. Q: An engineer proposes: "We should use GG20 for all chains (Ethereum, Bitcoin, Solana) to maintain a single MPC implementation and reduce code complexity." What is wrong and how to fix it?
   A: **Issue**: GG20 only supports ECDSA, which doesn't work for Solana's Ed25519 signatures. **Why**: Different chains use different signature schemes—Bitcoin/Ethereum use ECDSA (secp256k1), Solana uses EdDSA (ed25519). **Corrected**: Use protocol-chain alignment: CGGMP21 for ECDSA chains (Bitcoin/Ethereum), FROST for EdDSA/Schnorr (Solana), and implement chain-specific adapters while maintaining a chain-agnostic MPC core.

1. Q: A mobile developer states: "To reduce signing latency from 6s to 3s, we should reduce the threshold from 2-of-3 to 1-of-2 and remove one signing round from CGGMP21." What is wrong and how to fix it?
   A: **Issue**: Reducing threshold or removing protocol rounds compromises security guarantees. **Why**: 1-of-2 threshold loses Byzantine fault tolerance, and removing CGGMP21 rounds eliminates critical ZK range proofs that prevent malicious co-signer attacks. **Corrected**: Use offline pre-signing instead: CGGMP21 supports 3-round pre-signing that generates signing shares without knowing the transaction, reducing online phase to 1 round (cuts network latency from 2s to 500ms) while maintaining full security.

1. Q: A security architect designs: "Store all three 2-of-3 MPC key-shares in the same cloud provider across different availability zones to ensure high availability." What is wrong and how to fix it?
   A: **Issue**: Single cloud provider creates a shared risk boundary for all shares. **Why**: Provider-level compromise (insider threat, infrastructure breach, legal seizure) could expose multiple shares simultaneously, violating the security assumption of independent share storage. **Corrected**: Distribute shares across heterogeneous environments: mobile device TEE, backend HSM in separate infrastructure provider, and encrypted cloud backup under user control. Add geographic isolation and jurisdictional diversity for regulatory compliance.

1. Q: An engineer implements STRIDE threat modeling and concludes: "Since we use MPC, no single share reveals the private key, so we can skip implementing audit logs for HSM access." What is wrong and how to fix it?
   A: **Issue**: Conflates Information Disclosure mitigation with Repudiation and Elevation of Privilege risks. **Why**: While MPC prevents single-share key extraction, audit logs are essential for detecting insider threats (Elevation of Privilege), proving who authorized transactions (Repudiation), and meeting SOC 2/regulatory compliance. **Corrected**: Implement immutable audit logs for all HSM access, storing timestamp, user ID, transaction hash in append-only storage. Use KMS to enforce least-privilege RBAC with 2-of-3 admin quorum for sensitive operations.

1. Q: A PM prioritizes features: "Users want both social recovery and session keys urgently, so we'll build both in parallel to maximize user satisfaction." What is wrong and how to fix it?
   A: **Issue**: Ignores resource constraints and fails to quantify value-risk trade-offs. **Why**: Parallel development of complex security features spreads cryptography expertise thin, increases security review burden, and may result in both features launching with vulnerabilities. **Corrected**: Use WSJF prioritization: calculate (Business Value + Time Criticality + Risk Reduction) / Job Size for each. Based on the guidance, social recovery scores higher (addresses 30% support tickets, improves NPS from 40% user fear of loss) vs session keys (uncertain value, increases attack surface). Sequence features with staged validation.

1. Q: A backend engineer proposes: "To scale to 10,000 concurrent signing sessions, we should cache HSM responses for identical transaction hashes to reduce HSM load." What is wrong and how to fix it?
   A: **Issue**: Caching HSM signatures violates nonce uniqueness and enables replay attacks. **Why**: Each signature must use a fresh cryptographic nonce; reusing signatures allows attackers to replay transactions on different chains or contexts. **Corrected**: Scale HSM infrastructure horizontally with geographic redundancy instead. Cache only non-cryptographic data (transaction templates, policy validations). Use rate limiting and DDoS protection at API gateway. Implement pre-signing pools to separate key-generation load from signing load.

1. Q: An architect designs multi-chain support: "We'll create a single `sign(bytes)` API that accepts raw transaction bytes and returns a signature, letting client apps handle all chain-specific logic." What is wrong and how to fix it?
   A: **Issue**: Bypasses security policy enforcement at the MPC layer. **Why**: Signing raw bytes prevents the MPC service from validating transaction semantics (amount limits, address whitelisting, replay protection), allowing compromised clients to bypass security controls. **Corrected**: Implement a three-layer architecture: (1) Chain Abstraction Layer parses chain-specific transactions into canonical format, (2) Policy checks enforce amount limits/whitelists on canonical representation, (3) Signature Scheme Adapter invokes appropriate MPC protocol. API: `sign(chainId, canonicalTx, policyContext)`.

1. Q: A cryptography engineer states: "GG20 and CGGMP21 both do threshold ECDSA, so we should use GG20 because it's more mature and has more implementation libraries available." What is wrong and how to fix it?
   A: **Issue**: Ignores critical security vulnerabilities in GG20. **Why**: GG20 omits zero-knowledge range proofs in MtA (Multiplicative-to-Additive) share conversion, enabling key-extraction attacks by malicious co-signers. CGGMP21 fixes this with additional ZK proofs (adds ~30% computation but prevents attacks). **Corrected**: Use CGGMP21 for production systems handling real assets. Accept the 30% performance overhead for malicious-security guarantees. Document the decision in an ADR with threat model showing GG20 attack scenarios.

1. Q: A mobile team requests: "Make all cryptographic operations synchronous blocking calls so we don't have to deal with async/await complexity in our UI code." What is wrong and how to fix it?
   A: **Issue**: Blocking calls freeze the UI thread during multi-second MPC operations. **Why**: CGGMP21 signing takes 500ms-2s depending on network conditions; blocking the main thread causes ANR (Application Not Responding) errors on Android and unresponsive UI on iOS, leading to poor user experience and app crashes. **Corrected**: Use async/await or callback patterns; provide progress indicators and cancel capability. Implement pre-signing background tasks that run during app idle time, so online signing is near-instant when user initiates transaction.

1. Q: A security team recommends: "For post-quantum readiness, let's immediately migrate all MPC signing to Dilithium threshold signatures in production." What is wrong and how to fix it?
   A: **Issue**: Premature migration to immature post-quantum protocols risks security and performance. **Why**: NIST PQC threshold signature schemes are research-grade, not production-ready; they lack mature implementations, security audits, and have significantly larger key/signature sizes (10-100× larger) that may break mobile/web apps. **Corrected**: Phase migration: (1) Design modular Signature Scheme Adapter layer now to support future PQC integration, (2) Run 9-12 month research spike to prototype Dilithium threshold signatures in test environment, measure performance overhead, (3) Monitor NIST standardization and library maturity, (4) Migrate when threshold Dilithium has production-grade libraries and audit.

1. Q: A compliance officer states: "Since our MPC nodes are distributed globally, we can tell EU regulators that no single jurisdiction controls user keys, so GDPR data residency doesn't apply." What is wrong and how to fix it?
   A: **Issue**: Misunderstands GDPR data residency and key-share jurisdiction. **Why**: GDPR Article 33 and data residency rules apply to key-shares as "personal data"; having shares in multiple jurisdictions creates compliance obligations in all jurisdictions where shares reside. **Corrected**: Deploy region-specific HSM clusters: EU users' key-shares stay in EU data centers, US users in US, etc. Use geo-fencing to ensure key-share operations respect user jurisdiction. Document data flows in compliance artifacts and maintain audit logs per-region.

1. Q: An engineer optimizing performance disables CGGMP21 zero-knowledge range proofs in production, reasoning: "We control all signing nodes, so we don't need malicious-security proofs." What is wrong and how to fix it?
   A: **Issue**: Underestimates insider threat and node compromise risk. **Why**: Even trusted infrastructure can be compromised (insider attacks, supply chain attacks, zero-day exploits); removing ZK proofs allows a single compromised node to extract keys during signing. **Corrected**: Maintain full malicious-security (ZK range proofs) in production. Optimize performance through pre-signing, parallelization, and hardware acceleration instead. Use formal verification tools (ProVerif, Tamarin) to validate protocol security properties remain intact.

1. Q: A PM plans: "We'll launch social recovery using a 2-of-3 guardian threshold since it's simpler for users to set up than 5-of-9." What is wrong and how to fix it?
   A: **Issue**: 2-of-3 threshold provides insufficient security margin against collusion or compromise. **Why**: With only 3 guardians, if 2 collude or are compromised (e.g., family members on same device, email accounts on same provider), the wallet is recovered without user consent. **Corrected**: Use 3-of-5 minimum (better: 5-of-9) to balance security (tolerates up to 4 compromised guardians) and availability (only need 5 to recover). Add 48-hour timelock for guardian-initiated recovery to allow user dispute window.

1. Q: A developer implements chain support: "Ethereum L2s (Arbitrum, Optimism) use different VMs, so I'll create separate ChainAdapter implementations with different ECDSA signing logic for each." What is wrong and how to fix it?
   A: **Issue**: Misunderstands L2 architecture—most Ethereum L2s are EVM-compatible and use identical ECDSA signing. **Why**: Arbitrum and Optimism execute EVM bytecode and accept standard Ethereum transactions; only RPC endpoints and gas estimation differ. Creating duplicate signing logic increases code complexity and maintenance burden unnecessarily. **Corrected**: Reuse Ethereum ECDSA signing adapter for all EVM-compatible L2s; only implement chain-specific RPC client for different endpoints and gas estimation logic. Document in ADR that new L2 integration takes 2 weeks (RPC client) vs 1 month (full adapter).

1. Q: A security architect proposes: "To maximize redundancy, configure all 5 MPC nodes to participate in every 2-of-3 signing session, attempting all combinations until success." What is wrong and how to fix it?
   A: **Issue**: Misunderstands threshold signature mechanics and creates coordination complexity. **Why**: Threshold signatures require exactly k-of-n parties to participate per session (e.g., 2 specific nodes out of 3), not all n nodes running multiple combinations. Running all combinations would require complex coordination, waste computational resources, and may violate protocol security assumptions. **Corrected**: Use deterministic or random selection of k parties for each signing session. Implement fallback to alternate party sets only on explicit failure (timeout, abort), not proactively. Document party selection strategy in protocol design documentation.
