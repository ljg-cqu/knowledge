# MPC Wallet Engineer - Debug Cards

1. Q: An engineer implements a 3-of-5 threshold MPC wallet and claims: "Since we need 3 parties to sign, an attacker needs to compromise 3 parties to steal funds." What is wrong and how to fix it?
   A: **Issue**: Confuses signing threshold with security threshold. In a 3-of-5 scheme, only 3 shares are needed to reconstruct the key, so compromising ANY 3 parties enables theft. **Impact**: Overestimates security - attacker needs 60% (3/5) compromise, not "all parties." **Correction**: Accurate statement: "An attacker must compromise at least 3 of the 5 parties to reconstruct the private key and steal funds. The security model assumes at most 2 parties can be compromised."

1. Q: A developer states: "We'll use GG20 for Ethereum and FROST for Bitcoin since FROST is faster." What is wrong and how to fix it?
   A: **Issue**: Protocol-curve mismatch. GG20 is for ECDSA (secp256k1 used by both Ethereum and Bitcoin), while FROST is for Schnorr/EdDSA signatures. Bitcoin primarily uses ECDSA (though Taproot supports Schnorr). **Impact**: Implementation will fail - FROST cannot generate valid ECDSA signatures for standard Bitcoin transactions. **Correction**: "Use CGGMP21 or GG20 for both Ethereum and Bitcoin ECDSA signing. Consider FROST only for Bitcoin Taproot (Schnorr) or Solana (EdDSA) support."

1. Q: A security audit finds this code: `random_nonce = time.now() % curve_order`. The team claims: "This is fine because time.now() changes every millisecond." What is wrong and how to fix it?
   A: **Issue**: Predictable randomness - time.now() is not cryptographically secure, and an attacker observing signing time can predict nonces, enabling key extraction via lattice attacks. **Impact**: Critical vulnerability - nonce reuse or predictability breaks ECDSA security entirely, allowing full private key recovery. **Correction**: Use cryptographically secure random number generator: `random_nonce = crypto.secure_random_bytes(32) % curve_order` or implement RFC 6979 deterministic nonces derived from message hash and private key.

1. Q: An architect designs: "We'll store all 5 key shares in the same cloud provider for cost efficiency." What is wrong and how to fix it?
   A: **Issue**: Single point of failure - if the cloud provider is compromised (data breach, insider attack, subpoena), all shares are exposed simultaneously, defeating threshold security. **Impact**: Reduces threshold scheme to single-party risk, eliminating primary MPC benefit. **Correction**: Geographic and jurisdictional distribution: "Store shares across multiple independent providers (AWS US, Azure EU, GCP Asia) to ensure no single compromise yields enough shares to reconstruct the key."

1. Q: A mobile engineer implements offline signing: "Users can sign transactions while offline, and we'll broadcast them when they reconnect. We cache the last known nonce." What is wrong and how to fix it?
   A: **Issue**: Nonce reuse vulnerability - if network state changes while offline (e.g., user signs transaction from another device), cached nonce becomes stale, causing either transaction failure or double-nonce attacks if forced. **Impact**: Transaction failures, or if attacker can trigger nonce reuse, potential key extraction. **Correction**: "Implement nonce management with server-side nonce reservation or use deterministic nonce (RFC 6979) combined with transaction queue validation to prevent reuse."

1. Q: A performance optimization proposal states: "We'll pre-compute all elliptic curve multiplications and store them permanently to eliminate signing latency." What is wrong and how to fix it?
   A: **Issue**: Violates security - pre-computed values for all possible messages would require storing message-specific nonces or intermediate values, creating a massive key exposure risk if storage is compromised. **Impact**: Trades security for performance inappropriately - storage breach yields all signing material. **Correction**: "Pre-compute only round-independent operations (DKG setup, pre-signing phase in CGGMP21) that don't reveal information about specific transactions. Keep message-dependent operations online."

1. Q: A system design doc states: "For high availability, we'll replicate all HSM key shares across 3 data centers with real-time sync." What is wrong and how to fix it?
   A: **Issue**: Confuses availability with security - replicating shares within the same security domain increases availability but doesn't increase security (if one is compromised, all replicas are compromised). **Impact**: False sense of security while increasing operational risk through more attack surface. **Correction**: "Use HSM clustering for availability within one share (redundant HSMs protect one share), but distribute different shares across data centers. E.g., Share 1 replicated in DC1, Share 2 in DC2, Share 3 in DC3."

1. Q: A junior developer writes: "Since FROST requires only 2 rounds, I'll implement it for Ethereum to improve performance over GG20's 5 rounds." What is wrong and how to fix it?
   A: **Issue**: Signature scheme incompatibility - FROST generates Schnorr signatures, but Ethereum requires ECDSA signatures (secp256k1). They're not interchangeable. **Impact**: All signatures will be invalid and rejected by Ethereum network. **Correction**: "Use CGGMP21 (4 rounds) or optimized GG20 for Ethereum ECDSA. Reserve FROST for chains that support Schnorr (Bitcoin Taproot) or EdDSA (Solana)."

1. Q: A security review notes: "Our MPC implementation uses WebAssembly for portable cryptography, so we don't need platform-specific security." What is wrong and how to fix it?
   A: **Issue**: WebAssembly doesn't provide security isolation - it's a performance/portability tool. Key material in WASM memory is still vulnerable to side-channel attacks, memory dumps, or malware. **Impact**: False security assumption - WASM alone doesn't protect against memory-based attacks on mobile or web. **Correction**: "Use WASM for portable crypto operations, but integrate with platform security features (iOS Secure Enclave, Android Keystore, browser Web Crypto API) for key storage and sensitive operations."

1. Q: An implementation plan states: "We'll use the same MPC protocol instance for all users to share resources and improve efficiency." What is wrong and how to fix it?
   A: **Issue**: Key isolation violation - different users' key shares must never interact in the same protocol instance, or cross-user key leakage can occur. **Impact**: Catastrophic security failure - one user's compromise could leak information about other users' keys. **Correction**: "Maintain strict per-user protocol isolation with separate key shares, nonces, and session state. Resource sharing can occur at infrastructure level (same HSM cluster), but never at cryptographic protocol level."

1. Q: A monitoring dashboard shows: "MPC signing success rate: 99.8%, average latency: 450ms." Team concludes: "System is healthy." What is wrong and how to fix it?
   A: **Issue**: Ignores tail latencies and error patterns - average latency hides P95/P99 which matter for user experience, and 0.2% failure rate may be concentrated in specific conditions. **Impact**: Misses performance regressions affecting subset of users (mobile, specific chains, network conditions). **Correction**: "Monitor P95/P99 latency separately, segment metrics by device type/chain/network, and investigate failure rate trends over time. Set SLO: P95 < 800ms, failure rate < 0.5% with alerting on degradation."

1. Q: A code review shows: `if (signature_valid) { broadcast_transaction() }` without additional checks. Reviewer says it's fine because the signature is verified. What is wrong and how to fix it?
   A: **Issue**: Missing business logic validation - cryptographic validity doesn't guarantee transaction safety (amount limits, address whitelisting, policy compliance). **Impact**: Allows signing of malicious transactions that pass crypto validation but violate business rules. **Correction**: "Implement policy layer: `if (signature_valid && check_amount_limit() && check_whitelist() && check_nonce()) { broadcast_transaction() }` Separate crypto validation from business logic validation."

1. Q: A deployment plan states: "We'll upgrade all MPC nodes simultaneously during maintenance window to avoid version mismatches." What is wrong and how to fix it?
   A: **Issue**: Eliminates redundancy during critical operation - simultaneous upgrade means zero signing capacity during deployment, and rollback is all-or-nothing. **Impact**: Complete service outage during upgrade, high-risk deployment with no gradual validation. **Correction**: "Implement rolling deployment: upgrade one node at a time, validate signing success with mixed versions (protocol versioning), and maintain rollback capability. Use feature flags to control protocol version selection."

1. Q: An optimization proposal: "We'll cache transaction policy checks for 1 hour to reduce repeated validation overhead." What is wrong and how to fix it?
   A: **Issue**: Stale security policies - cached policy checks become invalid if policies update (e.g., address blacklist changes, amount limits adjusted), allowing previously-blocked transactions to succeed. **Impact**: Security bypass window up to 1 hour where updated policies aren't enforced. **Correction**: "Cache immutable transaction properties (signature validity for specific message) with short TTL (5 minutes), but always perform real-time policy checks. Use cache invalidation on policy updates."

1. Q: A disaster recovery plan states: "We backup HSM key shares daily to encrypted S3 buckets. In case of HSM failure, we'll restore from backup." What is wrong and how to fix it?
   A: **Issue**: HSM export vulnerability - if shares can be backed up, they can be extracted, violating HSM's primary security property (keys never leave tamper-proof boundary). **Impact**: Undermines HSM security model - backup process creates extraction vector. **Correction**: "Use HSM-to-HSM secure transfer for DR, never export shares to general-purpose storage. Implement key refresh (PSS) to regenerate shares without reconstruction. Maintain hot standby HSMs in different locations."
